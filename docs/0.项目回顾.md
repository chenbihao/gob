# 自我回顾

梳理复习在使用 Golang 搭建一个 web 框架过程中的迭代步骤。

项目地址：[GitHub - chenbihao/gob: go语言编写的web框架](https://github.com/chenbihao/gob)

## 01、搭建 Web Server

### net-http 标准库

Web Server 的本质就是通过接收并解析 HTTP 请求传输的文本字符，处理后包装成 HTTP 响应文本返回给客户端。

Go 官方提供了 `net/http` 库，方便我们直接创建 web 服务：

```go
// 创建一个Foo路由和处理函数
http.Handle("/foo", fooHandler)

// 创建一个bar路由和处理函数
http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
})

// 监听8080端口
log.Fatal(http.ListenAndServe(":8080", nil))
```

`net/http` 库主要提供了三类对外库函数（功能、func）：

- 为服务端提供创建 HTTP 服务的函数（名字中一般包含 Serve 字样）
- 为客户端提供调用 HTTP 服务的类库（以 HTTP 的 method 同名）
- 提供中转代理的一些函数（Proxy*）

核心结构（模块、struct）：

- Client 负责构建 HTTP 客户端
- Server 负责构建 HTTP 服务端
- ServerMux 负责 HTTP 服务端路由
- Transport、Request、Response、Cookie 负责客户端和服务端传输对应的不同模块

核心函数（能力、method）：

- 第一层：标准库创建 HTTP 服务是通过创建一个 Server 数据结构完成的
- 第二层：`Server` 数据结构在 `for` 循环中不断监听每一个连接
- 第三层：每个连接默认开启一个 Goroutine 为其服务
- 第四五层：`serverHandler` 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理
- 第六层：Server 数据结构如果没有设置处理函数 Handler，默认使用 `DefaultServerMux` 处理请求
- 第七层：`DefaultServerMux` 是使用 map 结构来存储和查找路由规则

## 02、控制请求上下文

### Context 标准库

> 包上下文定义 Context 类型，该类型跨 API 边界和进程之间传输截止时间、取消信号和其他请求范围的值。
>
> 对服务器的传入请求应创建 Context，对服务器的传出调用应接受 Context。它们之间的函数调用链必须传播 Context，也可以将其替换为使用 WithCancel、WithDeadline、WithTimeout 或 WithValue 创建的派生 Context。当一个 Context 被取消时，从它派生的所有 Context 也会被取消。
>
> 不要将 Contexts 存储在结构类型中; 相反，将 Context 显式传递给每个需要它的函数。Context 应为第一个参数，通常命名为 ctx。

库函数（功能、func）：

- `WithCancel`：直接创建可以操作退出的子节点，
- `WithTimeout`：为子节点设置了超时时间（还有多少时间结束）
- `WithDeadline`：为子节点设置了结束时间线（在什么时间结束）

核心结构（模块、struct）：

```go
type Context interface {
    // 当 Context 被取消或者到了 deadline，返回一个被关闭的 channel
    Done() <-chan struct{}
    ...
}

//函数句柄
type CancelFunc func()
```

在树形逻辑链条上， **一个节点其实有两个角色：一是下游树的管理者；二是上游树的被管理者**，那么就对应需要有两个能力：

- 一个是能让整个下游树结束的能力，也就是函数句柄 `CancelFunc`；
- 另外一个是在上游树结束的时候被通知的能力，也就是 `Done()` 方法。同时因为通知是需要不断监听的，所以 `Done()` 方法需要通过 `channel` 作为返回值让使用方进行监听。

官方示例：

```go
package main

import (
	"context"
	"fmt"
	"time"
)

const shortDuration = 1 * time.Millisecond

func main() {
    // 创建截止时间
	d := time.Now().Add(shortDuration)
    // 创建有截止时间的 Context
	ctx, cancel := context.WithDeadline(context.Background(), d)
	defer cancel()

    // 使用 select 监听 1s 和有截止时间的 Context 哪个先结束
	select {
	case <-time.After(1 * time.Second):
		fmt.Println("overslept")
	case <-ctx.Done():
		fmt.Println(ctx.Err())
	}
}
```

### net-http 标准库中应用的 Context 逻辑

![Context生成层次.jpg](https://cos.noobbb.cn/pictures/202312/19_Context%E7%94%9F%E6%88%90%E5%B1%82%E6%AC%A1.jpg)

每个连接的 Context 都是基于 baseContext 复制来的。

对应到代码中就是，在为某个连接开启 Goroutine 的时候，为当前连接创建了一个 `connContext`，这个 `connContext` 是基于 server 中的 Context （ `baseContext`）而来。

这两处都可以注入修改：

- `BaseContext` 是整个 Context 生成的源头，如果我们不希望使用默认的 `context.Backgroud()`，可以替换这个源头。
- 而在每个连接生成自己要使用的 Context 时，会调用 `ConnContext` ，它的第二个参数是 `net.Conn`，能让我们对某些特定连接进行设置，比如要针对性设置某个调用 IP。

源代码：

```go
type Server struct {
	...
    // BaseContext 用来为整个链条创建初始化 Context
    // 如果没有设置的话，默认使用 context.Background()
	BaseContext func(net.Listener) context.Context{}
	
    // ConnContext 用来为每个连接封装 Context
    // 参数中的 context.Context 是从 BaseContext 继承来的
	ConnContext func(ctx context.Context, c net.Conn) context.Context{}
    ...
}
```

### 目标：封装一个自己的 Context

前置：

```go
// 创建 framework 包存放框架文件
// framework 包外为业务文件
```

目标：封装一个自己的 Context：

```go
// 未封装的原生控制器的使用
func Foo1(request *http.Request, response http.ResponseWriter) {}

// 期待封装 Context 后的控制器使用
func Foo2(ctx *framework.Context) error {
	obj := map[string]interface{}{
		"data":   nil,
	}
    // 从请求体中获取参数
 	fooInt := ctx.FormInt("foo", 10)
    // 构建返回结构
	obj["data"] = fooInt
    // 输出返回结构
	return ctx.Json(http.StatusOK, obj)
}
```

将 `request` 和 `response` 封装到自定义的 Context 中，

并且兼容标准库的 Context 接口，`context.go` ：

```go
// 自定义 Context
type Context struct {
	request        *http.Request
	responseWriter http.ResponseWriter
	...
}

// 直接返回原生 Context
func (ctx *Context) BaseContext() context.Context {
	return ctx.request.Context()
}

// implement context.Context （实现标准 Context 接口）

func (ctx *Context) Deadline() (deadline time.Time, ok bool) {
	return ctx.BaseContext().Deadline()
}

func (ctx *Context) Done() <-chan struct{} {
	return ctx.BaseContext().Done()
}

func (ctx *Context) Err() error {
	return ctx.BaseContext().Err()
}

func (ctx *Context) Value(key any) any {
	return ctx.BaseContext().Value(key)
}
```

并且自己封装 Context 最终需要提供四类功能函数：

- `base` 封装基本的函数功能（比如获取 http.Request 结构）
- `context` 实现标准 Context 接口
- `request` 封装了 http.Request 的对外接口（query url、form post、json post 等）
- `response` 封装了 http.ResponseWriter 对外接口（Json、HTML、Text 等）

ControllerHandler 定义，框架目录 `controller.go` ：

```go
type ControllerHandler func(c *Context) error  
```

控制器使用，业务目录 `controller.go` ：

```go
func FooControllerHandler(ctx *framework.Context) error {  
    return ctx.Json(200, map[string]interface{}{  
        "code": 0,  
    })  
}  
```

### 目标：为单个请求设置超时

自定义 Context 设置超时：

1. 继承 request 的 Context，创建出一个设置超时时间的 Context；
2. 创建一个新的 Goroutine 来处理具体的业务逻辑；
3. 设计事件处理顺序，当前 Goroutine 监听超时时间 Contex 的 Done() 事件，和具体的业务处理结束事件，哪个先到就先处理哪个。

业务 `controller.go`：

```go
func FooControllerHandler(c *framework.Context) error {
	// 生成一个超时的 Context
	durationCtx, cancel := context.WithTimeout(c.BaseContext(), 1*time.Second)
	// 当所有事情处理结束后调用 cancel，告知 durationCtx 的后续 Context 结束
	defer cancel()

	finish := make(chan struct{}, 1)       // 这个 channel 负责通知结束
	panicChan := make(chan interface{}, 1) // 这个 channel 负责通知 panic 异常

	// 创建一个新的 Goroutine 来处理业务逻辑
	go func() {
		defer func() {
			if p := recover(); p != nil {
				panicChan <- p
			}
		}()
		
		// 这里做具体的业务
		time.Sleep(1 * time.Second)
		
		c.Json(200, "ok")
		finish <- struct{}{}
	}()

	select {
	case p := <-panicChan:      
		// 监听 panic
		c.WriterMux().Lock()
		defer c.WriterMux().Unlock()   // 考虑边界情况，加锁
		log.Println(p)
		c.Json(500, "panic")
	case <-finish:                
		// 监听结束事件
		fmt.Println("finish")
	case <-durationCtx.Done():    
		// 监听超时事件
		c.WriterMux().Lock()
		defer c.WriterMux().Unlock()   // 考虑边界情况，加锁
		c.Json(500, "time out")
		c.SetHasTimeout()        // 考虑边界情况，当触发超时后避免其他协程重复写入 （todo:没作写保护）
	}
	return nil
}
```

框架上下文添加超时与写保护 `context.go` ：

```go
// 自定义 Context
type Context struct {
	...
	hasTimeout bool        // 是否超时标记位
	writerMux  *sync.Mutex // 写保护机制
}
func NewContext(r *http.Request, w http.ResponseWriter) *Context {
	return &Context{
		request:        r,
		responseWriter: w,
		ctx:            r.Context(),
		writerMux:      &sync.Mutex{},
	}
}

...

func (ctx *Context) SetHasTimeout() {
	ctx.hasTimeout = true
}

func (ctx *Context) HasTimeout() bool {
	return ctx.hasTimeout
}

func (ctx *Context) WriterMux() *sync.Mutex {
	return ctx.writerMux
}

```

## 03、自定义路由功能

### 目标

路由一般使用的是请求头里的 `Method` 和 `Request-URI` 这两个部分。

希望使用者高效、易用地使用路由模块，基本需求可以有哪些呢？

- 需求 1：HTTP 方法匹配
- 需求 2：静态路由匹配
- 需求 3：批量通用前缀
- 需求 4：动态路由匹配
- 扩展需求：分组嵌套

### 如何实现

简单来讲，核心结构 `Core` 去实现 Handler 接口（`ServeHTTP`），来接管请求处理。

```go
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

并且在 `ServeHTTP` 函数里面，实现框架上下文 Context 的封装以及路由功能 router。

### 代码实现

最终代码 `main.go`：

```go
func main() {

	// 核心框架初始化
	core := framework.NewCore()

	// 设置路由
	registerRouter(core)

	server := &http.Server{
		// 自定义的请求核心处理函数
		Handler: core,
		// 请求监听地址
		Addr: ":8080",
	}
	server.ListenAndServe()
}
```

定义 ControllerHandler ，框架文件夹 `controller.go`：

```go
type ControllerHandler func(c *Context) error
```

并且简单实现几个业务 Controller ，例如业务文件夹的 `user_controller.go`：

```go
func UserLoginController(c *framework.Context) error {
	c.Json(200, "ok, UserLoginController")
	return nil
}
```

业务文件夹的注册路由 ，`router.go`：

```go
// 注册路由规则
func registerRouter(core *framework.Core) {
	// 需求1+2:HTTP方法+静态路由匹配
	core.Get("/user/login", UserLoginController)

	// 需求3:批量通用前缀
	subjectApi := core.Group("/subject")
	{
		// 需求4:动态路由
		subjectApi.Delete("/:id", SubjectDelController)
		subjectApi.Put("/:id", SubjectUpdateController)
		subjectApi.Get("/:id", SubjectGetController)
		subjectApi.Get("/list/all", SubjectListController)
		
		// 扩展需求：分组嵌套
		subjectInnerApi := subjectApi.Group("/info")
		{
			subjectInnerApi.Get("/name", SubjectNameController)
		}
	}
}
```

利用接口设计通用的分组定义，并且实现 `group.go`：

```go
// IGroup 代表前缀分组
type IGroup interface {
	// 实现HttpMethod方法
	Get(string, ControllerHandler)
	Post(string, ControllerHandler)
	Put(string, ControllerHandler)
	Delete(string, ControllerHandler)

	// 实现嵌套group
	Group(string) IGroup
}

// Group struct 实现了IGroup
type Group struct {
	core   *Core  // 指向core结构
	parent *Group // 指向上一个Group，如果有的话
	prefix string // 这个group的通用前缀
}

// 初始化Group
func NewGroup(core *Core, prefix string) *Group {
	return &Group{
		core:   core,
		parent: nil,
		prefix: prefix,
	}
}

// 实现Get方法
func (g *Group) Get(uri string, handler ControllerHandler) {
	uri = g.getAbsolutePrefix() + uri
	g.core.Get(uri, handler)
}

...  //  POST、PUT、DELETE

// 获取当前group的绝对路径
func (g *Group) getAbsolutePrefix() string {
	if g.parent == nil {
		return g.prefix
	}
	return g.parent.getAbsolutePrefix() + g.prefix
}

// 实现 Group 方法
func (g *Group) Group(uri string) IGroup {
	cgroup := NewGroup(g.core, uri)
	cgroup.parent = g
	return cgroup
}
```

核心框架代码，包含 Handler 接口实现、初始化路由、分组接口实现 。`core.go`：

```go
// 框架核心结构
type Core struct {
	router      map[string]*Tree    // all routers              // 一级匹配HTTP方法，二级字典树匹配
}

// 初始化Core结构
func NewCore() *Core {
	// 初始化路由
	router := map[string]*Tree{}
	router["GET"] = NewTree()
	router["POST"] = NewTree()
	router["PUT"] = NewTree()
	router["DELETE"] = NewTree()
	return &Core{router: router}
}

// 匹配GET 方法, 增加路由规则
func (c *Core) Get(url string, handler ControllerHandler) {
	if err := c.router["GET"].AddRouter(url, handler); err != nil {
		log.Fatal("add router error: ", err)
	}
}

...  //  POST、PUT、DELETE

// 前缀分组
func (c *Core) Group(prefix string) IGroup {
	return NewGroup(c, prefix)
}

// 匹配路由，如果没有匹配到，返回nil
func (c *Core) FindRouteByRequest(request *http.Request) ControllerHandler {
	// uri 和 method 全部转换为大写，保证大小写不敏感
	uri := request.URL.Path
	method := request.Method
	upperMethod := strings.ToUpper(method)

	// 查找第一层map
	if methodHandlers, ok := c.router[upperMethod]; ok {
		return methodHandlers.FindHandler(uri)
	}
	return nil
}

// 框架核心结构实现 Handler 接口
// 所有请求都进入这个函数, 这个函数负责路由分发
func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {

	// 封装自定义context
	ctx := NewContext(request, response)

	// 寻找路由
	router := c.FindRouteByRequest(request)
	if router == nil {
		// 如果没有找到，这里打印日志
		ctx.Json(404, "not found")
		return
	}

	// 调用路由函数，如果返回err 代表存在内部错误，返回500状态码
	if err := router(ctx); err != nil {
		ctx.Json(500, "inner error")
		return
	}
}
```

字典树的实现 ，`trie.go`：

```go
// 代表树结构
type Tree struct {
	root *node // 根节点
}

// 代表节点
type node struct {
	isLast   bool                // 是否可以成为最终的路由规则。该节点是否能成为一个独立的uri, 是否终极节点
	segment  string              // uri中的字符串，代表这个节点表示的路由中某个段的字符串
	handler ControllerHandler    // 代表这个节点中包含的控制器，用于最终加载调用
	childs   []*node             // 代表这个节点下的子节点
}

func newNode() *node {
	return &node{
		isLast:  false,
		segment: "",
		childs:  []*node{},
	}
}

func NewTree() *Tree {
	root := newNode()
	return &Tree{root}
}

// 判断一个segment是否是通用segment，即以:开头
func isWildSegment(segment string) bool {
	return strings.HasPrefix(segment, ":")
}

// 过滤下一层满足segment规则的子节点
func (n *node) filterChildNodes(segment string) []*node {
	if len(n.childs) == 0 {
		return nil
	}
	// 如果segment是通配符，则所有下一层子节点都满足需求
	if isWildSegment(segment) {
		return n.childs
	}
	nodes := make([]*node, 0, len(n.childs))
	// 过滤所有的下一层子节点
	for _, cnode := range n.childs {
		if isWildSegment(cnode.segment) {
			// 如果下一层子节点有通配符，则满足需求
			nodes = append(nodes, cnode)
		} else if cnode.segment == segment {
			// 如果下一层子节点没有通配符，但是文本完全匹配，则满足需求
			nodes = append(nodes, cnode)
		}
	}
	return nodes
}

// 判断路由是否已经在节点的所有子节点树中存在了
func (n *node) matchNode(uri string) *node {
	// 使用分隔符将uri切割为两个部分
	uri = strings.TrimPrefix(uri, "/") //  【/】开头的 url 去 Split 后第一层是空的，节省一层
	segments := strings.SplitN(uri, "/", 2)
	// 第一个部分用于匹配下一层子节点
	segment := segments[0]
	if !isWildSegment(segment) {
		segment = strings.ToUpper(segment)
	}
	// 匹配符合的下一层子节点
	cnodes := n.filterChildNodes(segment)

	// 如果当前子节点没有一个符合，那么说明这个uri一定是之前不存在, 直接返回nil
	if len(cnodes) == 0 {
		return nil
	}

	// 如果只有一个segment，则是最后一个标记
	if len(segments) == 1 {
		// 如果segment已经是最后一个节点，判断这些cnode是否有isLast标志
		for _, tn := range cnodes {
			if tn.isLast {
				return tn
			}
		}
		// 都不是最后一个节点
		return nil
	}

	// 如果有2个segment, 递归每个子节点继续进行查找
	for _, tn := range cnodes {
		tnMatch := tn.matchNode(segments[1])
		if tnMatch != nil {
			return tnMatch
		}
	}
	return nil
}

// 增加路由节点
func (tree *Tree) AddRouter(uri string, handler ControllerHandler) error {
	n := tree.root  
	
	// 确认路由是否冲突
	if n.matchNode(uri) != nil {
		return errors.New("route exist: " + uri)
	}
	uri = strings.TrimPrefix(uri, "/") //  【/】开头的 url 去 Split 后第一层是空的，节省一层
	segments := strings.Split(uri, "/")
	// 对每个segment
	for index, segment := range segments {

		// 最终进入Node segment的字段
		if !isWildSegment(segment) {
			segment = strings.ToUpper(segment)
		}
		isLast := index == len(segments)-1

		var objNode *node // 标记是否有合适的子节点

		childNodes := n.filterChildNodes(segment)
		// 如果有匹配的子节点
		if len(childNodes) > 0 {
			// 如果有segment相同的子节点，则选择这个子节点
			for _, cnode := range childNodes {
				if cnode.segment == segment {
					objNode = cnode
					break
				}
			}
		}

		if objNode == nil {
			// 创建一个当前node的节点
			cnode := newNode()
			cnode.segment = segment
			if isLast {
				cnode.isLast = true  
				cnode.handler = handler
			}
			n.childs = append(n.childs, cnode)
			objNode = cnode
		}
		n = objNode
	}
	return nil
}

// 匹配uri
func (tree *Tree) FindHandler(uri string) ControllerHandler {
	// 直接复用matchNode函数，uri是不带通配符的地址
	matchNode := tree.root.matchNode(uri)
	if matchNode == nil {
		return nil
	}
	return matchNode.handler
}
```

## 04、利用中间件提升扩展性

### 目标

03 说过，核心结构 `Core` 去实现 Handler 接口（`ServeHTTP`），来接管请求处理。

并且在 `ServeHTTP` 函数里面，实现框架上下文 Context 的封装以及路由功能 router。

在此基础上，把非业务逻辑的通用型需求，抽取成中间件来使用。

- 扩展需求 1：全局注册中间件
- 扩展需求 2：为单个路由注册中间件
- 扩展需求 3：为组嵌套中的单个路由注册中间件

以上都可以注册单个或者多个中间件

### 如何实现

改造成链路调用。

引入 pipeline 思想，将所有中间件做成一个链条，通过这个链条的调用，来实现中间件机制。

在架构层面，中间件机制就相当于，在每个请求的横切面统一注入了一个逻辑。

### 代码实现

最终使用效果，业务文件夹 `router.go`：

```go
// 注册路由规则
func registerRouter(core *framework.Core) {

	// 扩展需求1：core中使用use注册全局中间件 （需放在前面）
	core.Use(middleware.Recovery(), middleware.Cost())
	
	// 扩展需求2：在core中使用middleware.Test3() 为单个路由增加中间件
	core.Get("/user/login", middleware.Test3(), UserLoginController)

	subjectApi := core.Group("/subject")
	{
		...
		// 扩展需求3：在 group 中使用 middleware.Test3() 为单个路由增加中间件
		subjectApi.Get("/middleware/test3", middleware.Test3(), SubjectAddController)
	}
	core.Get("/timeout", middleware.Timeout(time.Second), TimeoutController)
}
```

字典树中的 Handler 改造成控制器链路 Handlers，找到路由 node 时也就能找到对应的控制器链路，`trie.go`：

```go
// 代表节点
type node struct {
	... 
	handlers []ControllerHandler // 中间件+控制器
}
...
// 增加路由节点
func (tree *Tree) AddRouter(uri string, handlers []ControllerHandler) error {
	...
				cnode.handlers = handlers
	...
}

// 匹配uri
func (tree *Tree) FindHandler(uri string) []ControllerHandler {
	matchNode := tree.root.matchNode(uri)
	if matchNode == nil {
		return nil
	}
	return matchNode.handlers
}

```

改造框架上下文，由上下文存储 handler 链条，并且维护一个链路下标，`context.go` ：

```go
// 自定义 Context
type Context struct {
	...
	handlers []ControllerHandler // 当前请求的handler链条
	index    int                 // 当前请求调用到调用链的哪个节点
}

func NewContext(r *http.Request, w http.ResponseWriter) *Context {
	return &Context{
		...
		writerMux:      &sync.Mutex{},
		index:          -1,
	}
}

// 为context设置handlers
func (ctx *Context) SetHandlers(handlers []ControllerHandler) {
	ctx.handlers = handlers
}

// 核心函数，调用context的下一个函数 
func (ctx *Context) Next() error {
	ctx.index++
	if ctx.index < len(ctx.handlers) {
		if err := ctx.handlers[ctx.index](ctx); err != nil {
			return err
		}
	}
	return nil
}
```

`Next()` 函数会在框架的两个地方被调用：

- 第一个是在此次请求处理的入口处，即 Core 的 ServeHttp；
- 第二个是在**每个中间件**的逻辑代码中，用于调用下个中间件。

上面是链路的改造，使框架中间件链路能顺利连起来，下面开始中间件注册。

- 首先为 Group 和 Core 两个结构增加注册中间件入口 `Use()`
- 并且在路由注册时，需要支持可变参数（`handlers ...ControllerHandler`）、聚合控制器（`allHandlers`）。

改造 Group，使中间件思想融入嵌套分组中 `group.go`：

```go
type IGroup interface {
	// 实现HttpMethod方法
	Get(string, ...ControllerHandler)
	Post(string, ...ControllerHandler)
	Put(string, ...ControllerHandler)
	Delete(string, ...ControllerHandler)

	// 实现嵌套group
	Group(string) IGroup
	// 嵌套中间件
	Use(middlewares ...ControllerHandler)
}
type Group struct {
	...
	middlewares []ControllerHandler // 存放中间件
}

// 实现Get方法
func (g *Group) Get(uri string, handlers ...ControllerHandler) {
	uri = g.getAbsolutePrefix() + uri
	allHandlers := append(g.getMiddlewares(), handlers...)  // 聚合
	g.core.Get(uri, allHandlers...)
}

...  // NewGroup  //  POST、PUT、DELETE

// 获取某个group的middleware
// 这里就是获取除了Get/Post/Put/Delete之外设置的middleware
func (g *Group) getMiddlewares() []ControllerHandler {
	if g.parent == nil {
		return g.middlewares
	}
	return append(g.parent.getMiddlewares(), g.middlewares...)
}

// 注册中间件
func (g *Group) Use(middlewares ...ControllerHandler) {
	g.middlewares = append(g.middlewares, middlewares...)
}
```

核心同步修改实现，增加全局中间件应用 ，`core.go`：

```go
// 框架核心结构
type Core struct {
	...
	middlewares []ControllerHandler // 从 core 这边设置的中间件   
}

... // NewCore

// 匹配 GET 方法, 增加路由规则
func (c *Core) Get(url string, handlers ...ControllerHandler) {
	// 将core的middleware 和 handlers结合起来
	allHandlers := append(c.middlewares, handlers...)
	if err := c.router["GET"].AddRouter(url, allHandlers); err != nil {
		log.Fatal("add router error: ", err)
	}
}

...  //  POST、PUT、DELETE   、Group

// 注册全局中间件
func (c *Core) Use(middlewares ...ControllerHandler) {
	c.middlewares = append(c.middlewares, middlewares...)
}

// 匹配路由，如果没有匹配到，返回nil
func (c *Core) FindRouteByRequest(request *http.Request) []ControllerHandler {
	...
}

// 框架核心结构实现 Handler 接口
// 所有请求都进入这个函数, 这个函数负责路由分发
func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {
	// 封装自定义context
	ctx := NewContext(request, response)

	// 寻找路由
	handlers := c.FindRouteByRequest(request)
	if handlers == nil {
		// 如果没有找到，这里打印日志
		ctx.Json(404, "not found")
		return
	}

	// 设置context中的handlers字段
	ctx.SetHandlers(handlers)

	// 调用路由函数，如果返回err 代表存在内部错误，返回500状态码
	if err := ctx.Next(); err != nil {
		ctx.Json(500, "inner error")
		return
	}
}
```

### 中间件的编写

在中间件中调用下一个链路（`ctx.Next()`），形成闭环。例如超时 `timeout.go`：

```go
func Timeout(d time.Duration) framework.ControllerHandler {
	// 使用函数回调
	return func(ctx *framework.Context) error {
		finish := make(chan struct{}, 1)
		panicChan := make(chan interface{}, 1)
		// 执行业务逻辑前预操作：初始化超时context
		durationCtx, cancel := context.WithTimeout(ctx.BaseContext(), d)
		defer cancel()

		go func() {
			defer func() {
				if p := recover(); p != nil {
					panicChan <- p
				}
			}()
			// 使用next执行具体的业务逻辑
			ctx.Next()

			finish <- struct{}{}
		}()
		// 执行业务逻辑后操作
		select {
		case p := <-panicChan:
			ctx.Json(500, "time out")
			log.Println(p)
		case <-finish:
			fmt.Println("finish")
		case <-durationCtx.Done():
			ctx.Json(500, "time out")
			ctx.SetHasTimeout()
		}
		return nil
	}
}
```

## 05、封装让框架更好用

### 目标

尽量在 context 这个数据结构中，封装“读取请求数据”和“封装返回数据”中的方法。

- 读取请求数据
    - Header 信息
        - 基础信息，比如请求地址、请求方法、请求 IP、请求域名、Cookie 信息等。
        - 更细节的内容编码格式、缓存时长等，由于涉及的 HTTP 协议细节内容比较多，我们很难将每个细节都封装出来，但是它们都是以 key=value 的形式传递到服务端的，所以这里也考虑封装一个通用的方法。
    - Body 信息（HTTP 是已经以某种形式封装好的）
        - 可能是 JSON 格式、XML 格式、其他格式
        - 也可能是 Form 表单格式
            - 它可能包含 File 文件，请求参数和返回值肯定和其他的 Form 表单字段是不一样的，需要我们对其单独封装一个函数

- 封装返回数据
    - Header 头部
        - 我们经常要设置的是返回状态码和 Cookie，所以单独为其封装。
        - 其他的 Header 同样是 key=value 形式设置的，设置一个通用的方法即可。
    - 返回 Body 体
        - 比如 JSON、JSONP、XML、HTML 或者其他文本格式，要针对不同的 Body 体形式，进行不同的封装

### 如何实现

首先，定义一个清晰的、包含若干个方法的接口，可以让使用者更加清晰明了地使用框架，同时做到“实现解耦”。

实现接口，可以利用 [第三方库cast](https://github.com/spf13/cast) 方便编码，利用官方库 [html/template](https://golang.org/pkg/html/template/) 方便模板数据替换。

### 代码实现

#### IRequest 接口定义与实现

读取请求数据 IRequest，`request.go`：

```go
// 代表请求包含的方法
type IRequest interface {
	// 请求地址 url 中带的参数
	// 形如: foo.com?a=1&b=bar&c[]=bar
	QueryInt(key string, def int) (int, bool)
	QueryInt64(key string, def int64) (int64, bool)
	QueryFloat64(key string, def float64) (float64, bool)
	QueryFloat32(key string, def float32) (float32, bool)
	QueryBool(key string, def bool) (bool, bool)
	QueryString(key string, def string) (string, bool)
	QueryStringSlice(key string, def []string) ([]string, bool)
	Query(key string) interface{}

	// 路由匹配中带的参数
	// 形如 /book/:id
	ParamInt(key string, def int) (int, bool)
	ParamInt64(key string, def int64) (int64, bool)
	ParamFloat64(key string, def float64) (float64, bool)
	ParamFloat32(key string, def float32) (float32, bool)
	ParamBool(key string, def bool) (bool, bool)
	ParamString(key string, def string) (string, bool)
	Param(key string) interface{}

	// form 表单中带的参数
	FormInt(key string, def int) (int, bool)
	FormInt64(key string, def int64) (int64, bool)
	FormFloat64(key string, def float64) (float64, bool)
	FormFloat32(key string, def float32) (float32, bool)
	FormBool(key string, def bool) (bool, bool)
	FormString(key string, def string) (string, bool)
	FormStringSlice(key string, def []string) ([]string, bool)
	FormFile(key string) (*multipart.FileHeader, error)
	Form(key string) interface{}

	// json body
	BindJson(obj interface{}) error
	// xml body
	BindXml(obj interface{}) error
	// 其他格式
	GetRawData() ([]byte, error)

	// 基础信息
	Uri() string
	Method() string
	Host() string
	ClientIp() string

	// header
	Headers() map[string][]string
	Header(key string) (string, bool)
	// cookie
	Cookies() map[string]string
	Cookie(key string) (string, bool)
}

const defaultMultipartMemory = 32 << 20 // 32 MB

var _ IRequest = new(Context) // 确保类型实现接口

// 获取请求地址中所有参数
func (ctx *Context) QueryAll() map[string][]string {
	if ctx.request != nil {
		return ctx.request.URL.Query()
	}
	return map[string][]string{}
}

... // Query* 

// 获取路由参数
func (ctx *Context) Param(key string) interface{} {
	if ctx.params != nil {
		if val, ok := ctx.params[key]; ok {
			return val
		}
	}
	return nil
}

... // Param* 

func (ctx *Context) FormAll() map[string][]string {
	if ctx.request != nil {
		ctx.request.ParseForm()
		return ctx.request.PostForm
	}
	return map[string][]string{}
}

func (ctx *Context) FormFile(key string) (*multipart.FileHeader, error) {
	if ctx.request.MultipartForm == nil {
		if err := ctx.request.ParseMultipartForm(defaultMultipartMemory); err != nil {
			return nil, err
		}
	}
	f, fh, err := ctx.request.FormFile(key)
	if err != nil {
		return nil, err
	}
	f.Close()
	return fh, err
}

... // Form* 

// 将body文本解析到obj结构体中
func (ctx *Context) BindJson(obj interface{}) error {
	if ctx.request != nil {
		// 读取文本
		body, err := ioutil.ReadAll(ctx.request.Body)
		if err != nil {
			return err
		}
		// 重新填充request.Body，为后续的逻辑二次读取做准备
		ctx.request.Body = ioutil.NopCloser(bytes.NewBuffer(body))

		// 解析到obj结构体中
		err = json.Unmarshal(body, obj)
		if err != nil {
			return err
		}
	} else {
		return errors.New("ctx.request empty")
	}
	return nil
}

// xml body
func (ctx *Context) BindXml(obj interface{}) error {
	if ctx.request != nil {
		body, err := ioutil.ReadAll(ctx.request.Body)
		if err != nil {
			return err
		}
		ctx.request.Body = ioutil.NopCloser(bytes.NewBuffer(body))

		err = xml.Unmarshal(body, obj)
		if err != nil {
			return err
		}
	} else {
		return errors.New("ctx.request empty")
	}
	return nil
}

// 其他格式
func (ctx *Context) GetRawData() ([]byte, error) {
	if ctx.request != nil {
		body, err := ioutil.ReadAll(ctx.request.Body)
		if err != nil {
			return nil, err
		}
		ctx.request.Body = ioutil.NopCloser(bytes.NewBuffer(body))
		return body, nil
	}
	return nil, errors.New("ctx.request empty")
}

// 基础信息
func (ctx *Context) Uri() string { return ctx.request.RequestURI }
func (ctx *Context) Method() string { return ctx.request.Method }
func (ctx *Context) Host() string { return ctx.request.URL.Host }

func (ctx *Context) ClientIp() string {
	r := ctx.request
	ipAddress := r.Header.Get("X-Real-Ip")
	if ipAddress == "" {
		ipAddress = r.Header.Get("X-Forwarded-For")
	}
	if ipAddress == "" {
		ipAddress = r.RemoteAddr
	}
	return ipAddress
}

func (ctx *Context) Headers() map[string][]string {
	return ctx.request.Header
}
func (ctx *Context) Header(key string) (string, bool) {
	vals := ctx.request.Header.Values(key)
	if vals == nil || len(vals) <= 0 {
		return "", false
	}
	return vals[0], true
}
func (ctx *Context) Cookies() map[string]string {
	cookies := ctx.request.Cookies()
	ret := map[string]string{}
	for _, cookie := range cookies {
		ret[cookie.Name] = cookie.Value
	}
	return ret
}
func (ctx *Context) Cookie(key string) (string, bool) {
	cookies := ctx.Cookies()
	if val, ok := cookies[key]; ok {
		return val, true
	}
	return "", false
}

```

#### IResponse 接口定义与实现

封装返回数据 IResponse，`response.go`：

```go
// IResponse 代表返回方法
type IResponse interface {
	Json(obj interface{}) IResponse
	Jsonp(obj interface{}) IResponse
	Xml(obj interface{}) IResponse
	Html(template string, obj interface{}) IResponse
	Text(format string, values ...interface{}) IResponse

	// 重定向
	Redirect(path string) IResponse
	// header
	SetHeader(key string, val string) IResponse
	SetCookie(key string, val string, maxAge int, path, domain string, secure, httpOnly bool) IResponse
	SetStatus(code int) IResponse
	SetOkStatus() IResponse
}

var _ IResponse = new(Context) // 确保类型实现接口

// Jsonp输出
func (ctx *Context) Jsonp(obj interface{}) IResponse {
	// 获取请求参数callback
	callbackFunc, _ := ctx.QueryString("callback", "callback_function")
	ctx.SetHeader("Content-Type", "application/javascript")
	// 输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成xss攻击
	callback := template.JSEscapeString(callbackFunc)

	// 输出函数名
	_, err := ctx.responseWriter.Write([]byte(callback))
	if err != nil { return ctx }
	// 输出左括号
	_, err = ctx.responseWriter.Write([]byte("("))
	if err != nil {	return ctx }
	// 数据函数参数
	ret, err := json.Marshal(obj)
	if err != nil {	return ctx }
	_, err = ctx.responseWriter.Write(ret)
	if err != nil {	return ctx }
	// 输出右括号
	_, err = ctx.responseWriter.Write([]byte(")"))
	if err != nil {	return ctx }
	return ctx
}

// xml输出
func (ctx *Context) Xml(obj interface{}) IResponse {
	byt, err := xml.Marshal(obj)
	if err != nil {
		return ctx.SetStatus(http.StatusInternalServerError)
	}
	ctx.SetHeader("Content-Type", "application/html")
	ctx.responseWriter.Write(byt)
	return ctx
}

// html输出
func (ctx *Context) Html(file string, obj interface{}) IResponse {
	// 读取模版文件，创建template实例
	t, err := template.New("output").ParseFiles(file)
	if err != nil { return ctx }
	// 执行Execute方法将obj和模版进行结合
	if err := t.Execute(ctx.responseWriter, obj); err != nil {
		return ctx
	}

	ctx.SetHeader("Content-Type", "application/html")
	return ctx
}

// string
func (ctx *Context) Text(format string, values ...interface{}) IResponse {
	out := fmt.Sprintf(format, values...)
	ctx.SetHeader("Content-Type", "application/text")
	ctx.responseWriter.Write([]byte(out))
	return ctx
}

// 重定向
func (ctx *Context) Redirect(path string) IResponse {
	http.Redirect(ctx.responseWriter, ctx.request, path, http.StatusMovedPermanently)
	return ctx
}

// header
func (ctx *Context) SetHeader(key string, val string) IResponse {
	ctx.responseWriter.Header().Add(key, val)
	return ctx
}

// Cookie
func (ctx *Context) SetCookie(key string, val string, maxAge int, path string, domain string, secure bool, httpOnly bool) IResponse {
	if path == "" {
		path = "/"
	}
	http.SetCookie(ctx.responseWriter, &http.Cookie{
		Name:     key,
		Value:    url.QueryEscape(val),
		MaxAge:   maxAge,
		Path:     path,
		Domain:   domain,
		SameSite: 1,
		Secure:   secure,
		HttpOnly: httpOnly,
	})
	return ctx
}

// 设置状态码
func (ctx *Context) SetStatus(code int) IResponse {
	ctx.responseWriter.WriteHeader(code)
	return ctx
}

// 设置200状态
func (ctx *Context) SetOkStatus() IResponse {
	ctx.responseWriter.WriteHeader(http.StatusOK)
	return ctx
}

func (ctx *Context) Json(obj interface{}) IResponse {
	byt, err := json.Marshal(obj)
	if err != nil {
		return ctx.SetStatus(http.StatusInternalServerError)
	}
	ctx.SetHeader("Content-Type", "application/json")
	ctx.responseWriter.Write(byt)
	return ctx
}

```

## 06、优雅关闭

### 目标

优雅关闭服务：关闭进程的时候，不能暴力关闭进程，要等进程中的所有请求都逻辑处理结束后才关闭进程。

分为两步：
- 控制关闭进程的操作
- 等待所有逻辑都处理结束

### 如何实现

#### 关闭进程的相关操作

- `Ctrl + C`：
    - 向进程发送信号 `SIGINT` 中断。可以被阻塞和处理的。
- `Ctrl + \`：
    - 向进程发送信号 `SIGQUIT`，和 `SIGINT` 差不多，可以被阻塞和处理的，默认行为会产生 core 文件。
- `Kill 命令`：
    - `kill pid` 会向进程发送 `SIGTERM` 信号，可以被阻塞和处理的
    - `kill -9 pid` 会向进程发送 `SIGKILL` 信号，不能被阻塞和处理的

在 Golang 标准库中提供了 `os/signal` 这个库可以用来捕获信号。

#### 等待所有逻辑都处理结束

在 Golang 1.8 版本之前，`net/http` 没有提供，可以用第三方库例如：[manners](https://github.com/braintree/manners) 、 [graceful](https://github.com/tylerstillwater/graceful) 、 [grace](https://github.com/facebookarchive/grace) 。

在 1.8 版本之后，`net/http` 引入了 `server.Shutdown` 来进行优雅重启。

标准库里实现了 `inShutdown` 原子标记，用来标记服务器是否正在关闭，真正执行操作的是 `closeIdleConns` 方法。这个方法循环判断所有连接中的请求是否已经完成操作（是否处于 Idle 状态）。

### 代码实现

```go
func main() {
	// 核心框架初始化
	core := framework.NewCore()
	// 设置路由
	registerRouter(core)
	server := &http.Server{
		// 自定义的请求核心处理函数
		Handler: core,
		// 请求监听地址
		Addr: ":8080",
	}

	// 这个goroutine是启动服务的goroutine
	go func() {
		server.ListenAndServe()
	}()

	// 当前的goroutine等待信号量
	quit := make(chan os.Signal)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	<-quit // 这里会阻塞当前goroutine等待信号

	// 设置超时关闭限制
	timeoutCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	// 调用Server.Shutdown graceful结束
	if err := server.Shutdown(timeoutCtx); err != nil {
		log.Fatal("Server Shutdown:", err)
	}

}
```

## 07、理想框架到底长什么样

### 开源框架怎么比较

可以参考的框架评判标准：

- **核心模块**
    - 服务启动方式、路由分发机制、上下文封装性、中间件机制设计等。
    - 理想的核心模块必须要有设计感，有自己的思想，代码质量、性能都不能出问题。
- **功能完备**
    - 是否提供日志模块、是否提供脚手架、命令行工具、缓存机制、ORM 等。
    - 希望不同水平的同学能写出基本一样的代码，那就要靠框架这个顶层设计来规范。
- **框架扩展**
    - 扩展功能时改动是否较大、是否支持功能实现的可插拔等。
    - 框架要做的事情应该是定义模块与模块之间的交互标准，而不应该直接定义模块的具体实现方式。
- **框架性能**
    - 框架每秒支持多少请求、是否有性能问题等。
    - 不应该把各个框架孤立出来看，应该将差不多量级的性能归为一组。
- **文档完备** / **社区活跃**
    - 是否有完善的文档支持、社区是否足够活跃、咨询问题多久回复等。
    - 从项目官网、GitHub 或邮件组上获取信息。

### 框架选择

[第三方测评结果](https://web-frameworks-benchmark.netlify.app/result) 可以用来查看各框架之间的性能对比。

[go-web-framework-stars](https://github.com/mingrammer/go-web-framework-stars)，可以用来获取实时流行度对比。

- **Beego**：功能很全的一个框架，设计感较为古早，从零快速开发场景适用。
- **Echo**：轻量，除了路由、Context 之外，都以 Middleware 形式提供，扩展性强，适合个人开发者。
- **Gin**：轻量，路由使用 [httprouter](https://github.com/julienschmidt/httprouter) 包，链式加载调用 Middleware，并且制定标准并开放 [社区贡献 organizations](https://github.com/gin-contrib)，社区活跃度高，扩展性强，适合企业级团队使用。

在保证框架的核心模块能满足要求的情况下，我们一般在功能完备性和框架扩展性之间取舍。

- 并发低、人少、开发快，可以优先考虑功能完备性；
- 高并发、团队、改动框架需求大，可以优先考虑扩展性；
- 更多灵活性，可以考虑从 `net/http` 标准库开始自研；

原则：**只选最适合的**

## 08、09、集成 Gin 替换已有核心

### 新旧框架差距：细节与生态

例如 `Recovery` 的错误捕获，Gin 也很细节的处理了底层连接的异常，并且进行堆栈信息打印等（细节处理）。

例如路由处理，Gin 选用了压缩后的基数树（radix tree），并且使用 `indices`、 `unsafe.Pointer` 等，优化查询效率减少资源消耗。

同时，Gin 社区也有共享开源中间件， [官方GitHub](https://github.com/orgs/gin-contrib/repositories) 组织收录的中间件有 23 个，非收录官方的在 [官方README](https://github.com/gin-gonic/contrib) 记录的也有 45 个。

这些中间件包含了 Web 开发各个方面的功能，比如提供跨域请求的 cors 中间件、提供本地缓存的 cache 中间件、集成了 pprof 工具的 pprof 中间件、自动生成全链路 trace 的 opengintracing 中间件等等。 **如果你用一个自己的框架，就需要重建生态一一开发，这是非常烦琐的，而且工作量巨大**。

### 站在巨人的肩膀才能做得更好

只有站在巨人的肩膀才能做得更好，如果是为了学习，直接从零自己边造轮子边学是个好方法； **但是如果你的目标是工业使用，那从零开始就非常不明智了**。

**其实很多市面上的框架，也都是基于已有的轮子来再开发的**。就拿 Gin 框架本身来说吧，它的路由是基于 [httprouter](https://github.com/julienschmidt/httprouter) 这个项目来定制化修改的；再比如 [Macaron](https://github.com/go-macaron/macaron) 框架，它是基于 [Martini](https://github.com/go-martini/martini) 框架的设计实现的。它们都是在原有的开源项目基础上，按照自己的设计思路重新改造的，也都获得了成功。

所以，我们先从零搭建出框架的核心部分，然后基于 Gin 来做进一步拓展和完善整个框架。

### 小结

**现代框架的理念不在于实现，而更多在于组合**。基于某些基础组件或者基础实现，不断按照自己或者公司的需求，进行二次改造和二次开发，从而打造出适合需求的形态。

比如 PHP 领域的 Laravel 框架，就是将各种底层组件、Symfony、Eloquent ORM、Monolog 等进行组装，而框架自身提供统一的组合调度方式；比如 Ruby 领域的 Rails 框架，整合了 Ruby 领域的各种优秀开源库。

**而框架的重点在于如何整理组件库、如何提供更便捷的机制，让程序员迅速解决问题**。

### 如何借力，开源项目的许可协议

最主流的开源许可证有 6 种：Apache、BSD、GPL、LGPL、MIT、Mozillia。

BSD 许可证、MIT 许可证和 Apache 许可证属于三个比较宽松的许可，都允许对源代码进行修改，且可以在闭源软件中使用，区别在于对新的修改，是否必须使用原先的许可证格式，以及修改后的软件是否能以原软件的名义进行销售等。

Gin 框架使用的 [MIT开源许可证](https://github.com/gin-gonic/gin/blob/master/LICENSE) ：

- 允许被许可人使用、复制、修改、合并、出版发行、散布、再许可、售卖软件及软件副本。
- 唯一条件是在软件和软件副本中必须包含著作权声明和本许可声明。

只需要在软件中包含著作权声明和许可协议声明就行，且不要求新的文件必须使用 MIT 协议。

### 如何将 Gin 迁移进框架

#### 复制项目与替换引用

复制项目进 `framework` 目录的 `gin` 子目录里

- 将 Gin 目录下的 `go.mod` 的内容复制到我们项目的 `go.mod` 里，并将 Gin 目录下的 `go.mod` 和 `go.sum` 删除。

```go
// 这里我从 module gob 改为为 module github.com/chenbihao/gob
// 引用到包相关的也需要改
// 例如 main.go 中的 import "gob/framework" 需改成 "github.com/chenbihao/gob/framework"
module github.com/用户名/项目名  // 不一定要项目地址，可以自定义

go 1.20

require (
	...  
	github.com/spf13/cast v1.6.0
)
```

- 将 Gin 中原有 Gin 库的引用地址，统一替换为当前项目的地址

将 Gin 框架中引用 `github.com/gin-gonic/gin` 的地方替换为 `github.com/用户名/项目名/framework/gin`

做完上述两步的操作之后，项目 `github.com/chenbihao/gob` 就包含了 Gin 1.9.1 了。

#### 迁移功能

梳理下目前已经实现的模块：

- Context（Gin 已有，逻辑差不多）
    - 作用：请求控制器，控制每个请求的超时等逻辑；
    - `Core` 数据结构对应 Gin 中的 `Engine`，
    - `Group` 数据结构对应 Gin 的 `Group` 结构，
    - `Context` 数据结构对应 Gin 的 `Context` 数据结构。
- 路由（Gin 已有，用的 [httprouter](https://github.com/julienschmidt/httprouter) ）
    - 作用：让请求更快寻找目标函数，并且支持通配符、分组等方式制定路由规则；
- 中间件（Gin 已有，无返回错误）
    - 作用：能将通用逻辑转化为中间件，并串联中间件实现业务逻辑；
- 封装（Gin 部分实现）
    - 作用：提供易用的逻辑，把 `request` 和 `response` 封装在 Context 结构中；
- 重启（直接用）
    - 作用：实现优雅关闭机制，让服务可以重启。

Context 实现基本一致，路由实现更好，中间件调整成无返回错误。

以上直接用实现得更好的 gin 框架内容，保留我们自己封装的优雅关闭，以及 `request` 和 `response` 。

#### 代码实现

`main.go` ：

```go
func main() {
	// 核心框架初始化
	// core := framework.NewCore()
	core := gin.New()   
	
	// 设置路由  
	registerRouter(core)
	...
}
```

注册路由也改为 gin 的用法，`router.go`：

```go
// 注册路由规则
// func registerRouter(core *framework.Core) {
func registerRouter(core *gin.Engine) {
	core.Use(gin.Recovery())  // 使用 gin 的 Recovery 中间件
	core.Use(middleware.Cost())
	// gin.Engine 的方法为全大写
	core.GET("/user/login", middleware.Test3(), UserLoginController)
	
	subjectApi := core.Group("/subject")
	{
		subjectApi.DELETE("/:id", SubjectDelController)
		subjectApi.PUT("/:id", SubjectUpdateController)
		subjectApi.GET("/:id", SubjectGetController)
		subjectApi.GET("/list/all", SubjectListController)
		subjectInnerApi := subjectApi.Group("/info")
		subjectInnerApi.GET("/name", SubjectNameController)
	}
	core.GET("/timeout", middleware.Timeout(10*time.Second), TimeoutController)
}
```

`context.go` 迁入 `gin` 文件夹里，并且改名为 `gob_context.go`，只保留 `BaseContext()` ：

```go
func (ctx *Context) BaseContext() context.Context {
	return ctx.Request.Context()
}
```

中间件改动，`middleware` 文件夹：

```go
func MiddlewareName() framework.ControllerHandler {
	return func(ctx *framework.Context) error {
	...  
	return nil
}}

// framework.ControllerHandler 改成 gin.HandlerFunc ，
// *framework.Context 改成 *gin.Context  并且去掉返回错误

func MiddlewareName() gin.HandlerFunc {
	return func(c *gin.Context) {
	...
}}
```

业务 `controller.go` 改动：

```go
func UserLoginController(c *framework.Context) error {

// 把 *framework.Context  改成 *gin.Context
// 去掉返回错误，并且把相关 IResponse 调整一下

func UserLoginController(c *gin.Context) {
```

`request.go` 与 `response.go` 迁入 `gin` 文件夹里，并且改名为 `gob_request.go` 与 `gob_response.go`，

改造 `gob_request.go`：

```go
// const defaultMultipartMemory = 32 << 20 // 32 MB

// 代表请求包含的方法
type IRequest interface {
	// 请求地址url中带的参数
	DefaultQueryInt(key string, def int) (int, bool)
	DefaultQueryInt64(key string, def int64) (int64, bool)
	DefaultQueryFloat64(key string, def float64) (float64, bool)
	DefaultQueryFloat32(key string, def float32) (float32, bool)
	DefaultQueryBool(key string, def bool) (bool, bool)
	DefaultQueryString(key string, def string) (string, bool)
	DefaultQueryStringSlice(key string, def []string) ([]string, bool)

	// 路由匹配中带的参数
	DefaultParamInt(key string, def int) (int, bool)
	DefaultParamInt64(key string, def int64) (int64, bool)
	DefaultParamFloat64(key string, def float64) (float64, bool)
	DefaultParamFloat32(key string, def float32) (float32, bool)
	DefaultParamBool(key string, def bool) (bool, bool)
	DefaultParamString(key string, def string) (string, bool)
	DefaultParam(key string) interface{}

	// form表单中带的参数
	DefaultFormInt(key string, def int) (int, bool)
	DefaultFormInt64(key string, def int64) (int64, bool)
	DefaultFormFloat64(key string, def float64) (float64, bool)
	DefaultFormFloat32(key string, def float32) (float32, bool)
	DefaultFormBool(key string, def bool) (bool, bool)
	DefaultFormString(key string, def string) (string, bool)
	DefaultFormStringSlice(key string, def []string) ([]string, bool)
	DefaultFormFile(key string) (*multipart.FileHeader, error)
	DefaultForm(key string) interface{}
}

var _ IRequest = new(Context) // 确保类型实现接口

// 获取请求地址中所有参数
func (ctx *Context) QueryAll() map[string][]string {
	ctx.initQueryCache()
	return ctx.queryCache
}

// gin 已经实现的
//func (ctx *Context) Query(key string) interface{} {

... // DefaultQuery*

// 获取路由参数
func (ctx *Context) DefaultParam(key string) interface{} {
	if val, ok := ctx.Params.Get(key); ok {
		return val
	}
	return nil
}

... // DefaultParam*

func (ctx *Context) FormAll() map[string][]string {
	ctx.initFormCache()
	return ctx.formCache
}
func (ctx *Context) DefaultFormFile(key string) (*multipart.FileHeader, error) {
	if ctx.Request.MultipartForm == nil {
		if err := ctx.Request.ParseMultipartForm(defaultMultipartMemory); err != nil {
			return nil, err
		}
	}
	f, fh, err := ctx.Request.FormFile(key)
	if err != nil {
		return nil, err
	}
	f.Close()
	return fh, err
}

... // DefaultForm*

```

`gob_response.go`：

```go
// IResponse 代表返回方法
type IResponse interface {
	// Json 输出
	IJson(obj interface{}) IResponse
	// Jsonp 输出
	IJsonp(obj interface{}) IResponse
	// xml 输出
	IXml(obj interface{}) IResponse
	// html 输出
	IHtml(template string, obj interface{}) IResponse
	// string
	IText(format string, values ...interface{}) IResponse

	// 重定向
	IRedirect(path string) IResponse

	// header
	ISetHeader(key string, val string) IResponse
	// Cookie
	ISetCookie(key string, val string, maxAge int, path, domain string, secure, httpOnly bool) IResponse
	// 设置状态码
	ISetStatus(code int) IResponse
	// 设置200状态
	ISetOkStatus() IResponse
}

var _ IResponse = new(Context) // 确保类型实现接口

// Jsonp输出
func (ctx *Context) IJsonp(obj interface{}) IResponse {
	// 获取请求参数callback
	callbackFunc := ctx.Query("callback")
	ctx.ISetHeader("Content-Type", "application/javascript")
	// 输出到前端页面的时候需要注意下进行字符过滤，否则有可能造成xss攻击
	callback := template.JSEscapeString(callbackFunc)

	// 输出函数名
	_, err := ctx.Writer.Write([]byte(callback))
	if err != nil { return ctx }
	// 输出左括号
	_, err = ctx.Writer.Write([]byte("("))
	if err != nil { return ctx }
	// 数据函数参数
	ret, err := json.Marshal(obj)
	if err != nil { return ctx }
	_, err = ctx.Writer.Write(ret)
	if err != nil { return ctx }
	// 输出右括号
	_, err = ctx.Writer.Write([]byte(")"))
	if err != nil { return ctx }
	return ctx
}

// xml输出
func (ctx *Context) IXml(obj interface{}) IResponse {
	byt, err := xml.Marshal(obj)
	if err != nil {
		return ctx.ISetStatus(http.StatusInternalServerError)
	}
	ctx.ISetHeader("Content-Type", "application/html")
	ctx.Writer.Write(byt)
	return ctx
}

// html输出
func (ctx *Context) IHtml(file string, obj interface{}) IResponse {
	// 读取模版文件，创建template实例
	t, err := template.New("output").ParseFiles(file)
	if err != nil {
		return ctx
	}
	// 执行Execute方法将obj和模版进行结合
	if err := t.Execute(ctx.Writer, obj); err != nil {
		return ctx
	}
	ctx.ISetHeader("Content-Type", "application/html")
	return ctx
}

// string
func (ctx *Context) IText(format string, values ...interface{}) IResponse {
	out := fmt.Sprintf(format, values...)
	ctx.ISetHeader("Content-Type", "application/text")
	ctx.Writer.Write([]byte(out))
	return ctx
}

func (ctx *Context) IRedirect(path string) IResponse {
	http.Redirect(ctx.Writer, ctx.Request, path, http.StatusMovedPermanently)
	return ctx
}
func (ctx *Context) ISetHeader(key string, val string) IResponse {
	ctx.Writer.Header().Add(key, val)
	return ctx
}
func (ctx *Context) ISetCookie(key string, val string, maxAge int, path string, domain string, secure bool, httpOnly bool) IResponse {
	if path == "" {
		path = "/"
	}
	http.SetCookie(ctx.Writer, &http.Cookie{
		Name:     key,
		Value:    url.QueryEscape(val),
		MaxAge:   maxAge,
		Path:     path,
		Domain:   domain,
		SameSite: 1,
		Secure:   secure,
		HttpOnly: httpOnly,
	})
	return ctx
}
func (ctx *Context) ISetStatus(code int) IResponse {
	ctx.Writer.WriteHeader(code)
	return ctx
}
func (ctx *Context) ISetOkStatus() IResponse {
	ctx.Writer.WriteHeader(http.StatusOK)
	return ctx
}
func (ctx *Context) IJson(obj interface{}) IResponse {
	byt, err := json.Marshal(obj)
	if err != nil {
		return ctx.ISetStatus(http.StatusInternalServerError)
	}
	ctx.ISetHeader("Content-Type", "application/json")
	ctx.Writer.Write(byt)
	return ctx
}

```

>[!note] 注意：在运行时需要 build 整个项目，否则会导致找不到方法
>
> Goland 中可以配置成：package 模式，包路径为：github.com/chenbihao/gob

#### 代码验证

调用 `go test ./...` 来运行 Gin 程序的所有测试用例，显示成功则表示我们的迁移成功。

并且通过 `go build && ./gob` 可以看到熟悉的 gin 调试模式的输出。

## 10、11、面向接口编程：封装服务

先接口后实现的方式，其实不仅仅是一种代码优化手段，更是一种编程思想：面向接口编程

### 如何理解面向接口编程

#### 抽象业务

首先，接口实现了对业务逻辑的抽象，设计接口就是抽象业务的过程。

#### 屏蔽具体实现

其次，接口的使用能让调用方对能力敏感，而对具体实现不敏感。

#### 面向接口/对象/过程

面向过程：缺点是一旦需求有一些变化，整个链路的改动都会受影响。

面向对象：抽象性强，但是封装性还不够。

面向接口：

面对业务，我们并不先定义具体的对象、思考对象有哪些属性，而是 **先思考如何抽象接口，把接口的定义放在第一步，然后多个模块之间梳理如何通过接口进行交互，最后才是实现具体的模块**。

### 接口服务的理论基础

按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现不关心，关心的是服务提供的能力，即接口协议。

**定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现。**

每个模块服务都做两件事情：

1. **服务提供者**（service provider）：
    - 提供是 “创建服务实例的方法”
    - 和自己提供的接口协议做绑定，这样当其他人要使用这个接口协议时能找到自己；
2. **服务容器**（service container）：
    - 提供 “实例化服务的方法”
    - 使用到其他接口协议的时候，去框架主体中寻找。

在框架初始化启动的时候，可以选择在服务容器中绑定多个服务提供者，每个服务提供者对应一个凭证。

当要使用到某个服务的时候，再根据这个凭证去服务容器中，获取这个服务提供者提供的服务。

**服务实例拥有哪些能力，即符合哪个接口协议，是预先在框架主体中定义好的。

### 服务提供者的接口定义

服务提供者需要以下能力：

- 三个基础能力
    - 获取服务凭证的能力 `Name`；
    - 注册服务实例化的方法的能力 `Register`；
    - 获取服务实例化方法参数的能力 `Params`；
- 两个与实例化控制相关的方法
    - 控制实例化时机方法 `IsDefer`
    - 实例化预处理的方法 `Boot`。

### 小结

定义好每个模块服务的接口，规范服务与服务之间的调用，并且管理每个服务的具体实现

### 服务容器的实现

#### 目标

框架的核心设计就是：框架主体作为一个服务容器，其他各个服务模块都作为服务提供者，在服务容器中注册自己的服务凭证和服务接口，通过服务凭证来获取具体的服务实例。

这样，功能的具体实现交给了各个服务模块，我们只需要规范服务提供者也就是服务容器中的接口协议。

#### 如何实现

##### 服务容器接口设计

**一个服务容器主要的功能是：为服务提供注册绑定、提供获取服务实例**，所以服务容器至少有两个方法：

- 注册方法 `Bind`、以及扩展出判断是否已绑定 `IsBind` 方法。
- 获取实例方法 `Make`，以及扩展出不返回 error 的 `MustMake` 方法。

考虑 `Make` 的一种拓展场景：

- 在获取服务实例的时候，按照不同参数初始化的 `MakeNew` 的方法，根据参数获取不同实例。

##### 服务容器具体设计

定义一个 GobContainer 数据结构，并且有 `map[string]interface{}` 结构 `instances`，其中 key 为关键字，value 为具体的服务实例，在 `Make` 系列的方法中，可以根据这个结构获取对应的服务实例。

服务提供方也需要设计一个 `map[string]ServiceProvider` 来存储它们，这样在 Bind 操作的时候，只需要将服务提供方绑定到某个关键字凭证上即可。

##### 容器与框架结合

绑定操作是全局的操作，而获取操作是在单个请求中使用的。所以在全局，我们为服务容器绑定了服务提供方，就能在单个请求中获取这个服务。

可以 **将服务容器存放在 Engine 中，并且在 Engine 初始化 Context 的时候，将服务容器传递进入 Context**。

#### 代码实现

服务提供者接口定义 `framework/provider.go` ：

```go
package framework

// NewInstance 定义了如何创建一个新实例，所有服务容器的创建服务
type NewInstance func(...interface{}) (interface{}, error)

// ServiceProvider 定义一个服务提供者需要实现的接口
type ServiceProvider interface {
	// Register 在服务容器中注册了一个实例化服务的方法，是否在注册的时候就实例化，需要参考 IsDefer 接口。
	Register(Container) NewInstance
	// Boot 在调用实例化服务的时候会调用，可以把一些准备工作：基础配置，初始化参数的操作放在这个里面。
	// 如果 Boot 返回 error，整个服务实例化就会实例化失败，返回错误
	Boot(Container) error
	// IsDefer 决定是否在注册的时候实例化这个服务，如果不是则在第一次 make 的时候进行实例化操作
	// false 表示不需要延迟实例化，在注册的时候就实例化。true 表示延迟实例化
	IsDefer() bool
	// Params params 定义传递给 NewInstance 的参数，可以自定义多个，建议将 container 作为第一个参数
	Params(Container) []interface{}
	// Name 代表了这个服务提供者的凭证
	Name() string
}
```

服务容器的接口设计与具体实现 `framework/container.go` ：

```go
// Container 是一个服务容器，提供绑定服务和获取服务的功能
type Container interface {
	// Bind 绑定一个服务提供者，如果关键字凭证已经存在，会进行替换操作，返回 error
	Bind(provider ServiceProvider) error
	// IsBind 关键字凭证是否已经绑定服务提供者
	IsBind(key string) bool
	// Make 根据关键字凭证获取一个服务
	Make(key string) (interface{}, error)
	// MustMake 根据关键字凭证获取一个服务，如果未绑定服务提供者，那么会 panic。
	// 在使用这个接口的时候请保证服务容器已经为这个关键字凭证绑定了服务提供者。
	MustMake(key string) interface{}
	// MakeNew 根据关键字凭证获取一个服务，只是这个服务并不是单例模式的
	// 它是根据服务提供者注册的启动函数和传递的 params 参数实例化出来的
	// 这个函数在需要为不同参数启动不同实例的时候非常有用
	MakeNew(key string, params []interface{}) (interface{}, error)
}

// GobContainer 是服务容器的具体实现
type GobContainer struct {
	Container                            // 强制要求 GobContainer 实现 Container 接口
	providers map[string]ServiceProvider // providers 存储注册的服务提供者，key 为字符串凭证
	instances map[string]interface{}     // instance 存储具体的实例，key 为字符串凭证
	lock      sync.RWMutex               // lock 用于锁住对容器的变更操作
}

// NewGobContainer 创建一个服务容器
func NewGobContainer() *GobContainer {
	return &GobContainer{
		providers: map[string]ServiceProvider{},
		instances: map[string]interface{}{},
		lock:      sync.RWMutex{},
	}
}


// Bind 将服务容器和关键字做了绑定
func (container *GobContainer) Bind(provider ServiceProvider) error {
	// 写锁
	container.lock.Lock()
	// key 为关键字，value 为注册的 ServiceProvider
	key := provider.Name()
	container.providers[key] = provider
	container.lock.Unlock()

	// key 为关键字，value 为注册的 ServiceProvider
	container.providers[key] = provider

	// if provider is not defer
	if provider.IsDefer() == false {
		if err := provider.Boot(container); err != nil {
			return err
		}
		// 实例化方法
		params := provider.Params(container)
		method := provider.Register(container)
		instance, err := method(params...)
		if err != nil {
			return errors.New(err.Error())
		}
		container.instances[key] = instance
	}
	return nil
}
func (container *GobContainer) IsBind(key string) bool {
	return container.findServiceProvider(key) != nil
}

func (container *GobContainer) findServiceProvider(key string) ServiceProvider {
	container.lock.RLock()
	defer container.lock.RUnlock()
	if sp, ok := container.providers[key]; ok {
		return sp
	}
	return nil
}

func (container *GobContainer) newInstance(sp ServiceProvider, params []interface{}) (interface{}, error) {
	// force new a
	if err := sp.Boot(container); err != nil {
		return nil, err
	}
	if params == nil {
		params = sp.Params(container)
	}
	method := sp.Register(container)
	ins, err := method(params...)
	if err != nil {
		return nil, errors.New(err.Error())
	}
	return ins, err
}

// Make 方式调用内部的 make 实现
func (container *GobContainer) Make(key string) (interface{}, error) {
	return container.make(key, nil, false)
}

// MustMake 方式调用内部的 make 实现
func (container *GobContainer) MustMake(key string) interface{} {
	serv, err := container.make(key, nil, false)
	if err != nil {
		panic(err)
	}
	return serv
}

// MakeNew 方式使用内部的 make 初始化
func (container *GobContainer) MakeNew(key string, params []interface{}) (interface{}, error) {
	return container.make(key, params, true)
}

// 真正的实例化一个服务
func (container *GobContainer) make(key string, params []interface{}, forceNew bool) (interface{}, error) {
	container.lock.RLock()
	defer container.lock.RUnlock()
	// 查询是否已经注册了这个服务提供者，如果没有注册，则返回错误
	sp := container.findServiceProvider(key)
	if sp == nil {
		return nil, errors.New("contract " + key + " have not register")
	}
	if forceNew {
		return container.newInstance(sp, params)
	}
	// 不需要强制重新实例化，如果容器中已经实例化了，那么就直接使用容器中的实例
	if ins, ok := container.instances[key]; ok {
		return ins, nil
	}

	// 容器中还未实例化，则进行一次实例化
	inst, err := container.newInstance(sp, nil)
	if err != nil {
		return nil, err
	}
	container.instances[key] = inst
	return inst, nil
}


```

容器与框架结合 - 服务容器的创建和传递

`framework/gin/gin.go` 中：

```go
type Engine struct {
	// gob改动：新增容器
	container framework.Container
    ...
}

func New() *Engine {
	debugPrintWARNINGNew()
	engine := &Engine{
		...
		// gob改动：这里注入了 container
		container:              framework.NewGobContainer(),
		...
	}
	...
	engine.pool.New = func() any {
		return engine.allocateContext(engine.maxParams)
	}
	return engine
}

// engine 创建 context
func (engine *Engine) allocateContext() *Context {
	v := make(Params, 0, engine.maxParams)
	// gob改动：注入容器到每个Context中（在分配新的 Context 的时候）
	return &Context{engine: engine, params: &v, container: engine.container}
}
```

`framework/gin/context.go` ：

```go
type Context struct {
	// gob改动：注入容器到每个Context中
	container framework.Container
	...
}
```

容器与框架结合 - 服务容器方法的封装

`Engine` 中负责绑定，`Context` 中负责获取，调整文件 `framework/gin/gob_context.go` ：

```go
// --- 基础能力

func (ctx *Context) BaseContext() context.Context {
	return ctx.Request.Context()
}

// --- 服务容器：engine 实现 container 的绑定封装

// Bind 绑定一个服务提供者，如果关键字凭证已经存在，会进行替换操作，返回 error
func (engine *Engine) Bind(provider framework.ServiceProvider) error {
	return engine.container.Bind(provider)
}

// IsBind 关键字凭证是否已经绑定服务提供者
func (engine *Engine) IsBind(key string) bool {
	return engine.container.IsBind(key)
}

// --- 服务容器：context 实现 container 的几个封装

// 实现 make 的封装
func (ctx *Context) Make(key string) (interface{}, error) {
	return ctx.container.Make(key)
}

// 实现 mustMake 的封装
func (ctx *Context) MustMake(key string) interface{} {
	return ctx.container.MustMake(key)
}

// 实现 makeNew 的封装
func (ctx *Context) MakeNew(key string, params []interface{}) (interface{}, error) {
	return ctx.container.MakeNew(key, params)
}

```

#### 代码验证

在业务目录中创建一个目录 `provider/demo` ，

接口说明文件 `contract.go`：

```go
// Demo 服务的 key
const Key = "gob:demo"

// Demo 服务的接口
type Service interface {
	GetFoo() Foo
}

// Demo 服务接口定义的一个数据结构
type Foo struct {
	Name string
}
```

ServiceProvider 实现文件 `provider.go`：

```go
// 服务提供方
type DemoServiceProvider struct {}

// Name 方法直接将服务对应的字符串凭证返回，在这个例子中就是“gob.demo"
func (sp *DemoServiceProvider) Name() string {
	return Key
}

// Register 方法是注册初始化服务实例的方法，这里先暂定为 NewDemoService
func (sp *DemoServiceProvider) Register(c framework.Container) framework.NewInstance {
	return NewDemoService
}

// IsDefer 方法表示是否延迟实例化，我们这里设置为 true，将这个服务的实例化延迟到第一次 make 的时候
func (sp *DemoServiceProvider) IsDefer() bool {
	return true
}

// Params 方法表示实例化的参数。我们这里只实例化一个参数：container，表示我们在 NewDemoService 这个函数中，只有一个参数，container
func (sp *DemoServiceProvider) Params(c framework.Container) []interface{} {
	return []interface{}{c}
}

// Boot 方法我们这里我们什么逻辑都不执行, 只打印一行日志信息
func (sp *DemoServiceProvider) Boot(c framework.Container) error {
	fmt.Println("demo service boot")
	return nil
}
```

实现具体的服务实例 `service.go` ：

```go
// 具体的接口实例
type DemoService struct {
	// 参数
	c framework.Container
}

// var _ Service = &DemoService{} // 确保已经实现 Service 接口
var _ Service = new(DemoService) // 确保已经实现 Service 接口

// 实现接口
func (s *DemoService) GetFoo() Foo {
	return Foo{
		Name: "i am foo",
	}
}

// 初始化实例的方法
func NewDemoService(params ...interface{}) (interface{}, error) {
	// 这里需要将参数展开
	c := params[0].(framework.Container)

	fmt.Println("new demo service")
	// 返回实例
	return &DemoService{c: c}, nil
}

```

测试调用 `subject_controller.go` ：

```go
// 对应路由 /subject/list/all
func SubjectListController(c *gin.Context) {
	// 获取 demo 服务实例
	demoService := c.MustMake(demo.Key).(demo.Service)
	// 调用服务实例的方法
	foo := demoService.GetFoo()
	// 输出结果
	c.ISetOkStatus().IJson(foo)
}
```

## 12、设计框架的整体目录

### 目录划分

从框架层来规范业务的目录结构，不仅是一种分目录的设计，还贯彻了面向接口的思想，将目录作为一个服务提供在服务容器中

根目录下划分为五个文件夹：app、framework、config、storage、test。

- `app` ：存放业务相关代码
    -  `http`：提供 Web 服务
        - `middleware`：web 特有通用中间件
        - `module`：每个子目录代表一个模块服务
    -  `console` ：提供控制台进程
        - `command`：命令行工具实现
    -  `provider` ：通用的服务提供者
        - 服务协议的 `contract.go` 文件
        - 服务提供者的 `provider.go` 文件
        - 具体服务实现的 `service.go` 文件
- `framework` 框架所有的代码
    - `gin`：集成 Gin 框架
    - `contract`：框架默认提供的服务协议
    - `provider` ：服务协议的具体实现以及服务提供者（子目录对应服务）
    - `command`：提供框架自带命令行工具
    - `middleware`：框架为 Web 服务提供的中间件
    - `util` ：通用工具函数
- `config` ：配置文件
- `test` ：测试相关
- `storage`：存储相关
    - `log` ：日志
    - `runtime` ：运行时

### 定义框架基础 App 服务

#### 代码实现

定义 App 服务的接口协议 `framework/contract/app.go` ：

```go
// 接口说明文件 contract.go

// AppKey 定义字符串凭证
const AppKey = "gob:app"

// App 定义接口（提供了获取框架相关内容，例如获取框架约定的相关目录）
type App interface {
	// Version 定义当前版本
	Version() string
	// BaseFolder 定义项目基础地址
	BaseFolder() string
	// ConfigFolder 定义了配置文件的路径
	ConfigFolder() string
	// LogFolder 定义了日志所在路径
	LogFolder() string
	// ProviderFolder 定义业务自己的服务提供者地址
	ProviderFolder() string
	// MiddlewareFolder 定义业务自己定义的中间件
	MiddlewareFolder() string
	// CommandFolder 定义业务定义的命令
	CommandFolder() string
	// RuntimeFolder 定义业务的运行中间态信息
	RuntimeFolder() string
	// TestFolder 存放测试所需要的信息
	TestFolder() string
}

```

App 服务实现 `ServiceProvider` 接口，`framework/provider/app/provider.go` ：

```go
// ServiceProvider 实现文件 provider.go

// GobAppProvider 提供App的具体实现方法
type GobAppProvider struct {
	BaseFolder string
}
var _ framework.ServiceProvider = (*GobAppProvider)(nil)

// Register 注册 GobApp 方法
func (appProvider *GobAppProvider) Register(container framework.Container) framework.NewInstance {
	return NewGobApp
}
// Boot 启动调用
func (appProvider *GobAppProvider) Boot(container framework.Container) error {
	return nil
}
// IsDefer 是否延迟初始化
func (appProvider *GobAppProvider) IsDefer() bool {
	return false
}
// Params 获取初始化参数
func (appProvider *GobAppProvider) Params(container framework.Container) []interface{} {
	return []interface{}{container, appProvider.BaseFolder}
}
// Name 获取字符串凭证
func (appProvider *GobAppProvider) Name() string {
	return contract.AppKey
}
```

实现 App 服务，`framework/provider/app/service.go` ：

```go
// 实现具体的服务实例 service.go

// GobApp 代表 gob 框架的 App 实现
type GobApp struct {
	container  framework.Container // 服务容器
	baseFolder string              // 基础路径
}
var _ contract.App = (*GobApp)(nil)

// Version 实现版本
func (app GobApp) Version() string {
	return "0.1.1"
}

// BaseFolder 表示基础目录，可以代表开发场景的目录，也可以代表运行时候的目录
func (app GobApp) BaseFolder() string {
	if app.baseFolder != "" {
		return app.baseFolder
	}
	// 如果没有设置，则使用参数
	var baseFolder string
	flag.StringVar(&baseFolder, "base_folder", "", "base_folder 参数, 默认为当前路径")
	flag.Parse()
	if baseFolder != "" {
		return baseFolder
	}
	// 如果参数也没有，使用默认的当前路径
	return util.GetExecDirectory()
}

// ConfigFolder  表示配置文件地址
func (app GobApp) ConfigFolder() string {
	return filepath.Join(app.BaseFolder(), "config")
}
// LogFolder 表示日志存放地址
func (app GobApp) LogFolder() string {
	return filepath.Join(app.StorageFolder(), "log")
}
func (app GobApp) HttpFolder() string {
	return filepath.Join(app.BaseFolder(), "http")
}
func (app GobApp) ConsoleFolder() string {
	return filepath.Join(app.BaseFolder(), "console")
}
func (app GobApp) StorageFolder() string {
	return filepath.Join(app.BaseFolder(), "storage")
}
// ProviderFolder 定义业务自己的服务提供者地址
func (app GobApp) ProviderFolder() string {
	return filepath.Join(app.BaseFolder(), "provider")
}
// MiddlewareFolder 定义业务自己定义的中间件
func (app GobApp) MiddlewareFolder() string {
	return filepath.Join(app.HttpFolder(), "middleware")
}
// CommandFolder 定义业务定义的命令
func (app GobApp) CommandFolder() string {
	return filepath.Join(app.ConsoleFolder(), "command")
}
// RuntimeFolder 定义业务的运行中间态信息
func (app GobApp) RuntimeFolder() string {
	return filepath.Join(app.StorageFolder(), "runtime")
}
// TestFolder 定义测试需要的信息
func (app GobApp) TestFolder() string {
	return filepath.Join(app.BaseFolder(), "test")
}
// NewGobApp 初始化 GobApp
func NewGobApp(params ...interface{}) (interface{}, error) {
	if len(params) != 2 {
		return nil, errors.New("param error")
	}
	// 有两个参数，一个是容器，一个是 baseFolder
	container := params[0].(framework.Container)
	baseFolder := params[1].(string)
	return GobApp{baseFolder: baseFolder, container: container}, nil // todo 这里可能得规范下返回的是指针或者实体
}
```

通用方法，`util.go`：

```go
// GetExecDirectory 获取当前执行程序目录
func GetExecDirectory() string {
	file, err := os.Getwd()
	if err == nil {
		return file + "/"
	}
	return ""
}
```

#### 代码验证

```go
// 对应路由 /subject/list/all
func SubjectListController(c *gin.Context) {
	// 获取 App 服务实例
	appService := c.MustMake(contract.AppKey).(app.GobApp)
	// 输出结果
	c.ISetOkStatus().IJson(appService.ConfigFolder())
}
```

## 13、交互：执行命令行

### 目标

引入命令行工具库，并改造整个项目

### 如何实现

- 源码引入
- 把服务容器嵌入 `Command`
- 把 Web 服务封装成命令
    - 准备工作：把创建 Web 服务引擎的方法作为一个服务封装在服务容器中
    - main 函数的改造：初始化一个服务容器，然后将各个服务绑定到这个服务容器中，包括定义的提供 Web 引擎的服务
    - 在业务代码中将业务需要的路由绑定到 Web 引擎中去
    - 完成服务的绑定之后，最后要创建一个 `根Command`，并且创建一个 Web 启动的 `Command`

### 代码实现

#### 源码引入

引入命令行工具库 [cobra](https://github.com/spf13/cobra)，许可证允许，复制进 `framework/cobra`，并且迁移 `go.mod` 内容。

#### 把服务容器嵌入

单独抽取 engine 实现 container 的绑定封装 ，并且新增设置容器方法 `SetContainer`， `/framework/gin/gob_engine.go`：

```go
// --- 服务容器：engine 实现 container 的绑定封装

// Bind 绑定一个服务提供者，如果关键字凭证已经存在，会进行替换操作，返回 error
func (engine *Engine) Bind(provider framework.ServiceProvider) error {
	return engine.container.Bind(provider)
}

// IsBind 关键字凭证是否已经绑定服务提供者
func (engine *Engine) IsBind(key string) bool {
	return engine.container.IsBind(key)
}

// SetContainer 设置服务容器
func (engine *Engine) SetContainer(container framework.Container) {
	engine.container = container
}
```

在 `framework/cobra/command.go` 中修改 `Command` 结构，加入服务容器：

```go
type Command struct {
	// gob改动：引入服务容器
	container framework.Container
	...
}
```

再为 `Command` 提供两个方法：设置服务容器、获取服务容器，单独创建 `framework/cobra/gob_command.go` ：

```go
// SetContainer 设置服务容器
func (c *Command) SetContainer(container framework.Container) {
	c.container = container
}
// GetContainer 获取容器
func (c *Command) GetContainer() framework.Container {
	return c.Root().container
}
```

#### 把 Web 服务封装成命令

准备工作：把创建 Web 服务引擎的方法作为一个服务封装在服务容器中

在 `framework/contract/kernel.go` 中，把创建 `Engine` 的过程封装为一个服务接口协议：

```go
// KernelKey 提供 kenel 服务凭证
const KernelKey = "gob:kernel"

// Kernel 接口提供框架最核心的结构
type Kernel interface {
	// HttpEngine http.Handler结构，作为net/http框架使用, 实际上是gin.Engine
	HttpEngine() http.Handler
}

```

在 `framework/provider/kernel/provider.go` 中定义一个服务提供者：

```go
// GobKernelProvider 提供web引擎
type GobKernelProvider struct {
	HttpEngine *gin.Engine
}
// Register 注册服务提供者
func (provider *GobKernelProvider) Register(c framework.Container) framework.NewInstance {
	return NewGobKernelService
}
// Boot 启动的时候判断是否由外界注入了Engine，如果注入的化，用注入的，如果没有，重新实例化
func (provider *GobKernelProvider) Boot(c framework.Container) error {
	if provider.HttpEngine == nil {
		provider.HttpEngine = gin.Default()
	}
	provider.HttpEngine.SetContainer(c)
	return nil
}
// IsDefer 引擎的初始化我们希望开始就进行初始化
func (provider *GobKernelProvider) IsDefer() bool {
	return false
}
// Params 参数就是一个HttpEngine
func (provider *GobKernelProvider) Params(c framework.Container) []interface{} {
	return []interface{}{provider.HttpEngine}
}
// Name 提供凭证
func (provider *GobKernelProvider) Name() string {
	return contract.KernelKey
}
```

初始化实例 `framework/provider/kernel/service.go` ：

```go
// 引擎服务
type GobKernelService struct {
	engine *gin.Engine
}

var _ contract.Kernel = (*GobKernelService)(nil)

// 初始化 web 引擎服务实例
func NewGobKernelService(params ...interface{}) (interface{}, error) {
	httpEngine := params[0].(*gin.Engine)
	return &GobKernelService{engine: httpEngine}, nil
}
// 返回 web 引擎
func (s *GobKernelService) HttpEngine() http.Handler {
	return s.engine
}
```

main 函数的改造：初始化一个服务容器，然后将各个服务绑定到这个服务容器中，包括定义的提供 Web 引擎的服务

`main.go`：

```go
func main() {

	// 初始化服务容器
	container := framework.NewGobContainer()
	// 绑定 App 服务提供者
	container.Bind(&app.GobAppProvider{})

	// 后续初始化需要绑定的服务提供者...

	// 将 HTTP 引擎初始化,并且作为服务提供者绑定到服务容器中
	if engine, err := http.NewHttpEngine(); err == nil {
		// 绑定 Kernel 服务提供者
		container.Bind(&kernel.GobKernelProvider{HttpEngine: engine})
	}
	// 运行root命令
	console.RunCommand(container)
}
```

在业务代码中将业务需要的路由绑定到 Web 引擎中去

`http.NewHttpEngine` 这个创建 Web 引擎的方法必须放在业务层，因为这个 Web 引擎不仅仅是调用了 Gin 创建 Web 引擎的方法，更重要的是调用了业务需要的绑定路由的功能。

创建引擎 `app/http/kernel.go` ：

```go
// NewHttpEngine 创建了一个绑定了路由的 Web 引擎
func NewHttpEngine() (*gin.Engine, error) {
	// 设置为 Release，为的是默认在启动中不输出调试信息
	gin.SetMode(gin.ReleaseMode)
	// 默认启动一个 Web 引擎
	r := gin.Default()
	// 业务绑定路由操作
	Routes(r)
	// 返回绑定路由后的 Web 引擎
	return r, nil
}
```

绑定路由 `app/http/route.go` ：

```go
// Routes 绑定业务层路由
func Routes(r *gin.Engine) {
	r.Static("/dist/", "./dist/")
	demo.Register(r) // 这个demo是业务App自定义的demo服务,位置在 `app/http/module/demo/*`
}
```

完成服务的绑定之后，最后要创建一个 `根Command`，并且创建一个 Web 启动的二级 `Command`，

`app/console/kernel.go` ：

```go
// RunCommand  初始化根Command并运行
func RunCommand(container framework.Container) error {
	// 根Command
	var rootCmd = &cobra.Command{
		// 定义根命令的关键字
		Use: "gob",
		// 简短介绍
		Short: "gob 命令",
		// 根命令的详细介绍
		Long: "gob 框架提供的命令行工具，使用这个命令行工具能很方便执行框架自带命令，也能很方便编写业务命令",
		// 根命令的执行函数
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.InitDefaultHelpFlag()
			return cmd.Help()
		},
		// 不需要出现cobra默认的completion子命令
		CompletionOptions: cobra.CompletionOptions{DisableDefaultCmd: true},
	}

	// 为根Command设置服务容器
	rootCmd.SetContainer(container)
	// 绑定框架的命令  （框架定义的命令我们使用`framework/command/kernel.go` 中的 `AddKernelCommands` 进行挂载）
	command.AddKernelCommands(rootCmd)
	// 绑定业务的命令
	AddAppCommand(rootCmd)

	// 执行RootCommand
	return rootCmd.Execute()
}

// 绑定业务的命令（业务定义的命令我们使用 `app/console/kernel.go` 中的 `AddAppCommand`进行挂载）
func AddAppCommand(rootCmd *cobra.Command) {
	//  demo 例子
	rootCmd.AddCommand(demo.InitFoo())
}
```

这里绑定了一个业务代码的 demo 命令用来测试，`app/console/command/demo/foo.go` ：

```go
// InitFoo 初始化Foo命令
func InitFoo() *cobra.Command {
	FooCommand.AddCommand(Foo1Command)
	return FooCommand
}

// FooCommand 代表Foo命令
var FooCommand = &cobra.Command{
	Use:     "foo",
	Short:   "foo的简要说明",
	Long:    "foo的长说明",
	Aliases: []string{"fo", "f"},
	Example: "foo命令的例子",
	RunE: func(c *cobra.Command, args []string) error {
		container := c.GetContainer()
		log.Println(container)
		return nil
	},
}
```

前面在 `app/console` 里创建了根命令，并且加载了框架与业务命令初始化，这里初始化框架相关的命令，`framework/command/kernel.go` ：

```go
// AddKernelCommands will add all command/* to root command
func AddKernelCommands(root *cobra.Command) {
	// 挂载AppCommand命令
	root.AddCommand(initAppCommand())
}

```

封装二级 Web 启动 App 命令， `framework/command/app.go`：

```go
// initAppCommand 初始化app命令和其子命令
func initAppCommand() *cobra.Command {
	appCommand.AddCommand(appStartCommand)
	return appCommand
}

// AppCommand 是命令行参数第一级为app的命令，它没有实际功能，只是打印帮助文档
var appCommand = &cobra.Command{
	Use:   "app",
	Short: "业务应用控制命令",
	Long:  "业务应用控制命令，其包含业务启动，关闭，重启，查询等功能",
	RunE: func(c *cobra.Command, args []string) error {
		// 打印帮助文档
		c.Help()
		return nil
	},
}

// appStartCommand 启动一个Web服务
var appStartCommand = &cobra.Command{
	Use:   "start",
	Short: "启动一个Web服务",
	RunE: func(c *cobra.Command, args []string) error {
		// 从Command中获取服务容器
		container := c.GetContainer()
		// 从服务容器中获取kernel的服务实例
		kernelService := container.MustMake(contract.KernelKey).(contract.Kernel)
		// 从kernel服务实例中获取引擎
		core := kernelService.HttpEngine()

		// 创建一个Server服务
		server := &http.Server{
			Handler: core,
			Addr:    ":8080",
		}
		// 这个goroutine是启动服务的goroutine
		go func() {
			server.ListenAndServe()
		}()

		// 当前的goroutine等待信号量
		quit := make(chan os.Signal)
		// 监控信号：SIGINT, SIGTERM, SIGQUIT
		signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
		// 这里会阻塞当前goroutine等待信号
		<-quit

		// 调用Server.Shutdown graceful结束
		timeoutCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := server.Shutdown(timeoutCtx); err != nil {
			log.Fatal("Server Shutdown:", err)
		}
		return nil
	},
}
```

### 代码验证

创建一个业务服务测试 demo，`/app/http/module/demo/api.go`：

```go
type DemoApi struct {
	service *Service
}

func Register(r *gin.Engine) error {
	api := NewDemoApi()
	r.Bind(&demoService.DemoProvider{})

	r.GET("/demo/demo", api.Demo)
	r.GET("/demo/demo2", api.Demo2)
	r.POST("/demo/demo_post", api.DemoPost)
	return nil
}

func NewDemoApi() *DemoApi {
	service := NewService()
	return &DemoApi{service: service}
}

// Demo godoc
// @Summary 获取所有用户
// @Description 获取所有用户
// @Produce  json
// @Tags demo
// @Success 200 array []UserDTO
// @Router /demo/demo [get]
func (api *DemoApi) Demo(c *gin.Context) {
	//appService := c.MustMake(contract.AppKey).(contract.App)
	//baseFolder := appService.BaseFolder()
	users := api.service.GetUsers()
	usersDTO := UserModelsToUserDTOs(users)
	c.JSON(200, usersDTO)
}

// Demo godoc
// @Summary 获取所有学生
// @Description 获取所有学生
// @Produce  json
// @Tags demo
// @Success 200 array []UserDTO
// @Router /demo/demo2 [get]
func (api *DemoApi) Demo2(c *gin.Context) {
	demoProvider := c.MustMake(demoService.DemoKey).(demoService.IService)
	students := demoProvider.GetAllStudent()
	usersDTO := StudentsToUserDTOs(students)
	c.JSON(200, usersDTO)
}

func (api *DemoApi) DemoPost(c *gin.Context) {
	type Foo struct {
		Name string
	}
	foo := &Foo{}
	err := c.BindJSON(&foo)
	if err != nil {
		c.AbortWithError(500, err)
	}
	c.JSON(200, nil)
}
```

整体框架验证：`go build` 编译后调用 `./gob` （或者直接 `go run .`）。

web 服务验证： `./gob app start`，可以访问到业务定义的 `/demo/demo` 路径。

## 14、定时任务：支持分布式定时脚本

### 如何实现

使用开源定时执行库 [cron](https://github.com/robfig/cron) ，支持极其丰富的“时间描述语言”，且支持秒级定时。

将功能封装进 Command 里，

### 代码实现

#### 引入框架

在 `framework/cobra/command.go` 中修改 `Command` 结构，加入定时库：

```go
type Command struct {
	// gob改动：引入定时库  
	Cron *cron.Cron // Command支持cron，只在RootCommand中有这个值  
	CronSpecs []CronSpec // 对应Cron命令的信息
	...
}
```

#### cron 的初始化和回调

绑定业务时添加定时任务命令， `app/console/kernel.go` ：

```go
// 绑定业务的命令（业务定义的命令我们使用 `app/console/kernel.go` 中的 `AddAppCommand`进行挂载）
func AddAppCommand(rootCmd *cobra.Command) {
	...
	// 每秒调用一次Foo命令
	rootCmd.AddCronCommand("* * * * * *", demo.FooCommand)
}
```

再为 `根Command` 提供保存 `Cron` 命令方法： `framework/cobra/gob_command.go` ：

```go
// CronSpec 保存Cron命令的信息，用于展示
type CronSpec struct {
	Type        string
	Cmd         *Command
	Spec        string
	ServiceName string
}

func (c *Command) SetParentNull() {
	c.parent = nil
}

// AddCronCommand 是用来创建一个Cron任务的
func (c *Command) AddCronCommand(spec string, cmd *Command) {
	// cron结构是挂载在根Command上的
	root := c.Root()
	if root.Cron == nil {
		// 初始化cron
		root.Cron = cron.New(cron.WithParser(cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))
		root.CronSpecs = []CronSpec{}
	}
	// 增加说明信息
	root.CronSpecs = append(root.CronSpecs, CronSpec{
		Type: "normal-cron",
		Cmd:  cmd,
		Spec: spec,
	})

	// 制作一个rootCommand，成为一个新的根节点
	var cronCmd Command
	ctx := root.Context()
	cronCmd = *cmd
	cronCmd.args = []string{}
	cronCmd.SetParentNull()
	cronCmd.SetContainer(root.GetContainer())

	// 增加调用函数
	root.Cron.AddFunc(spec, func() {
		// 如果后续的command出现panic，这里要捕获
		defer func() {
			if err := recover(); err != nil {
				log.Println(err)
			}
		}()
		err := cronCmd.ExecuteContext(ctx)
		if err != nil {
			// 打印出err信息
			log.Println(err)
		}
	})
}

```

#### 启动 cron

利用开源库 [go-daemon](https://github.com/sevlyar/go-daemon) 来实现守护进程模式。

初始化命令，并且 deamon 模式可选（如果支持），`framework/command/cron.go` ：

```go
var cronDaemon = false

func initCronCommand() *cobra.Command {
	// 以后台 deamon 的方式启动的参数
	cronStartCommand.Flags().BoolVarP(&cronDaemon, "daemon", "d", false, "start serve daemon")
	cronCommand.AddCommand(cronRestartCommand)
	cronCommand.AddCommand(cronStateCommand)
	cronCommand.AddCommand(cronStopCommand)
	cronCommand.AddCommand(cronListCommand)
	cronCommand.AddCommand(cronStartCommand)
	return cronCommand
}

var cronCommand = &cobra.Command{
	Use:   "cron",
	Short: "定时任务相关命令",
	RunE: func(c *cobra.Command, args []string) error {
		if len(args) == 0 {
			c.Help()
		}
		return nil
	},
}

// serveCommand start a app serve
var cronListCommand = &cobra.Command{
	Use:   "list",
	Short: "列出所有的定时任务",
	RunE: func(c *cobra.Command, args []string) error {

		cronSpecs := c.Root().CronSpecs
		ps := [][]string{}
		for _, cronSpec := range cronSpecs {
			line := []string{cronSpec.Type, cronSpec.Spec, cronSpec.Cmd.Use, cronSpec.Cmd.Short, cronSpec.ServiceName}
			ps = append(ps, line)
		}
		util.PrettyPrint(ps)
		return nil
	},
}

// cron进程的启动服务
var cronStartCommand = &cobra.Command{
	Use:   "start",
	Short: "启动cron常驻进程",
	RunE: func(c *cobra.Command, args []string) error {
		// 获取容器
		container := c.GetContainer()
		// 获取容器中的app服务
		appService := container.MustMake(contract.AppKey).(contract.App)

		// 设置cron的日志地址和进程id地址
		pidFolder := appService.RuntimeFolder()
		serverPidFile := filepath.Join(pidFolder, "cron.pid")
		logFolder := appService.LogFolder()
		serverLogFile := filepath.Join(logFolder, "cron.log")
		currentFolder := appService.BaseFolder()

		// deamon 模式
		if cronDaemon {
			// win不支持 deamon 模式
			if util.IsWindows() {
				return errors.New("daemon: Non-POSIX OS is not supported")
			}
			// 创建一个Context
			cntxt := &daemon.Context{
				// 设置pid文件
				PidFileName: serverPidFile,
				PidFilePerm: 0664,
				// 设置日志文件
				LogFileName: serverLogFile,
				LogFilePerm: 0640,
				// 设置工作路径
				WorkDir: currentFolder,
				// 设置所有设置文件的mask，默认为750
				Umask: 027,
				// 子进程的参数，按照这个参数设置，子进程的命令为 ./gob cron start --daemon=true
				Args: []string{"", "cron", "start", "--daemon=true"},
			}
			// 启动子进程，d不为空表示当前是父进程，d为空表示当前是子进程
			d, err := cntxt.Reborn()
			if err != nil {
				return err
			}
			if d != nil {
				// 父进程直接打印启动成功信息，不做任何操作
				fmt.Println("cron serve started, pid:", d.Pid)
				fmt.Println("log file:", serverLogFile)
				return nil
			}

			// 子进程执行Cron.Run
			defer cntxt.Release()
			fmt.Println("daemon started")
			//gspt.SetProcTitle("gob cron") // win上无法使用
			c.Root().Cron.Run()
			return nil
		}

		// not deamon mode
		fmt.Println("start cron job")
		content := strconv.Itoa(os.Getpid())
		fmt.Println("[PID]", content)

		// todo 这里可以优化变成覆写
		if err := ioutil.WriteFile(serverPidFile, []byte(content), 0664); err != nil {
			return err
		}

		//gspt.SetProcTitle("gob cron") // win上无法使用
		c.Root().Cron.Run()
		return nil
	},
}
... // cronRestartCommand、cronStopCommand、cronStateCommand
```

挂载进框架，`framework/command/kernel.go`：

```go
// AddKernelCommands will add all command/* to root command
func AddKernelCommands(root *cobra.Command) {
	...
	// 挂载 cron
	root.AddCommand(initCronCommand())
}
```

>[!tips]
> win 不支持 daemon，好像也无法引用 gspt 库（守护进程相关），这里注释掉

#### 分布式定时器

这里先定义一个接口，利用本地文件锁来实现本地分布式选择器，后续也可以利用 Redis 实现。

定义一个分布式的选择器，在 `framework/contract/distributed.go` ：

```go
// DistributedKey 定义字符串凭证
const DistributedKey = "gob:distributed"

// Distributed 分布式服务
type Distributed interface {

	// Select 分布式选择器, 所有节点对某个服务进行抢占，只选择其中一个节点
	// ServiceName 服务名字
	// appID 当前的AppID
	// holdTime 分布式选择器hold住的时间
	// selectAppID 分布式选择器最终选择的App
	// err 异常才返回，如果没有被选择，不返回err
	Select(serviceName string, appID string, holdTime time.Duration) (selectAppID string, err error)
}
```

这里的 `appID` 是利用 [uuid生成库](https://github.com/google/uuid) 生成的，在 `framework/contract/framework/contract/app.go` 中增加 AppID 的接口函数：

```go
// App 定义接口
type App interface {
   // AppID 表示当前这个app的唯一id, 可以用于分布式锁等
   AppID() string
   ...
}
```

在 `framework/provider/app/service.go` 中也增加对 AppID 的实现：

```go
import{
	...
	"github.com/google/uuid"
}

// GobAppService 代表 gob 框架的 App 实现
type GobAppService struct {
   ...
   appId      string              // 表示当前这个app的唯一id, 可以用于分布式锁等
}

// AppID 表示当前这个app的唯一id, 可以用于分布式锁等
func (s GobAppService) AppID() string {
	return s.appID
}

// NewGobApp 初始化 GobAppService
func NewGobApp(params ...interface{}) (interface{}, error) {
	...
	appID := uuid.New().String()
	// todo 这里可能得规范下返回的是指针或者实体
	return GobAppService{baseFolder: baseFolder, container: container, appID: appID}, nil
}
```

实现 `framework/provider/distributed/provider_local.go`，这里省略。

分布式服务 Distributed 的具体实现，`framework/provider/distributed/service_local.go` ：

```go
//go:build !windows
... 
// LocalDistributedService
type LocalDistributedService struct {
	container framework.Container // 服务容器
}

var _ contract.Distributed = (*LocalDistributedService)(nil)

// NewLocalDistributedService 初始化本地分布式服务
func NewLocalDistributedService(params ...interface{}) (interface{}, error) {
	if len(params) != 1 {
		return nil, errors.New("param error")
	}

	container := params[0].(framework.Container)
	return &LocalDistributedService{container: container}, nil
}

// Select 为分布式选择器   （这里win不支持syscall.Flock，作废，换兼容性更好的）
func (s LocalDistributedService) Select(serviceName string, appID string, holdTime time.Duration) (selectAppID string, err error) {
	appService := s.container.MustMake(contract.AppKey).(contract.App)
	runtimeFolder := appService.RuntimeFolder()
	lockFile := filepath.Join(runtimeFolder, "disribute_"+serviceName)

	// 打开文件锁
	lock, err := os.OpenFile(lockFile, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return "", err
	}

	// 尝试独占文件锁
	err = syscall.Flock(int(lock.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
	// 抢不到文件锁
	if err != nil {
		// 读取被选择的appid
		selectAppIDByt, err := ioutil.ReadAll(lock)
		if err != nil {
			return "", err
		}
		return string(selectAppIDByt), err
	}

	// 在一段时间内，选举有效，其他节点在这段时间不能再进行抢占
	go func() {
		defer func() {
			// 释放文件锁
			syscall.Flock(int(lock.Fd()), syscall.LOCK_UN)
			// 释放文件
			lock.Close()
			// 删除文件锁对应的文件
			os.Remove(lockFile)
		}()
		// 创建选举结果有效的计时器
		timer := time.NewTimer(holdTime)
		// 等待计时器结束
		<-timer.C
	}()

	// 这里已经是抢占到了，将抢占到的appID写入文件
	if _, err := lock.WriteString(appID); err != nil {
		return "", err
	}
	return appID, nil
}

```

>[!tips]
>win 不支持 Flock 文件锁，所以额外实现一个 win 构建专用版

win 版简单实现，调用 `kernel32.dll` 的 `LockFile` 方法来进行文件锁，`framework/provider/distributed/service_local_win.go` ：

```go
//go:build windows

// LocalDistributedService
type LocalDistributedService struct {
	container framework.Container // 服务容器
}

var _ contract.Distributed = (*LocalDistributedService)(nil)

// NewLocalDistributedService 初始化本地分布式服务
func NewLocalDistributedService(params ...interface{}) (interface{}, error) {
	if len(params) != 1 {
		return nil, errors.New("param error")
	}

	container := params[0].(framework.Container)
	return &LocalDistributedService{container: container}, nil
}

// Select 为分布式选择器   （这里win不支持syscall.Flock，作废，换兼容性更好的）
func (s LocalDistributedService) Select(serviceName string, appID string, holdTime time.Duration) (selectAppID string, err error) {
	appService := s.container.MustMake(contract.AppKey).(contract.App)
	runtimeFolder := appService.RuntimeFolder()
	lockFile := filepath.Join(runtimeFolder, "disribute_"+serviceName+".txt")

	// 打开文件锁
	lock, err := os.OpenFile(lockFile, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return "", err
	}

	// win 下使用文件锁
	h, err := syscall.LoadLibrary("kernel32.dll")
	if err != nil {
		return
	}
	defer syscall.FreeLibrary(h)

	addr, err := syscall.GetProcAddress(h, "LockFile")
	if err != nil {
		return
	}
	r0, _, _ := syscall.Syscall6(addr, 5, lock.Fd(), 0, 0, 0, 1, 0)
	if 0 == int(r0) {
		// 加锁失败，只读的形式读取占用中的appid
		selectAppIDByt, readErr := ioutil.ReadAll(lock)
		if readErr != nil {
			if strings.Contains(readErr.Error(), "another process has locked a portion of the file.") {
				return "ReadFileFailed", nil
			}
			return "", readErr
		}
		return string(selectAppIDByt), err
	}

	// 在一段时间内，选举有效，其他节点在这段时间不能再进行抢占
	go func() {
		defer func() {
			// 释放文件锁
			addr, err = syscall.GetProcAddress(h, "UnlockFile")
			if err != nil {
				return
			}
			syscall.Syscall6(addr, 5, lock.Fd(), 0, 0, 0, 1, 0)

			// 释放文件
			lock.Close()
		}()
		// 创建选举结果有效的计时器
		timer := time.NewTimer(holdTime)
		// 等待计时器结束
		<-timer.C
	}()

	// 这里已经是抢占到了，将抢占到的appID写入文件
	if _, err = lock.WriteString(appID); err != nil {
		return "", err
	}
	return appID, nil
}
```

分布式调度实现在 `framework/cobra/gob_command_distributed.go` ：

```go
// AddDistributedCronCommand 实现一个分布式定时器
// serviceName 这个服务的唯一名字，不允许带有空格
// spec 具体的执行时间
// cmd 具体的执行命令
// holdTime 表示如果我选择上了，这次选择持续的时间，也就是锁释放的时间
func (c *Command) AddDistributedCronCommand(serviceName string, spec string, cmd *Command, holdTime time.Duration) {
	root := c.Root()
	// 初始化cron
	if root.Cron == nil {
		root.Cron = cron.New(cron.WithParser(cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)))
		root.CronSpecs = []CronSpec{}
	}
	// cron命令的注释，这里注意Type为distributed-cron，ServiceName需要填写
	root.CronSpecs = append(root.CronSpecs, CronSpec{
		Type:        "distributed-cron",
		Cmd:         cmd,
		Spec:        spec,
		ServiceName: serviceName,
	})
	appService := root.GetContainer().MustMake(contract.AppKey).(contract.App)
	distributeServce := root.GetContainer().MustMake(contract.DistributedKey).(contract.Distributed)
	appID := appService.AppID()
	// 复制要执行的command为cronCmd，并且设置为rootCmd
	var cronCmd Command
	ctx := root.Context()
	cronCmd = *cmd
	cronCmd.args = []string{}
	cronCmd.SetParentNull()
	cronCmd.container = root.GetContainer() // 这里也传递上下文
	// cron增加匿名函数
	root.Cron.AddFunc(spec, func() {
		// 防止panic
		defer func() {
			if err := recover(); err != nil {
				log.Println(err)
			}
		}()
		// 节点进行选举，返回选举结果
		selectedAppID, err := distributeServce.Select(serviceName, appID, holdTime)
		if err != nil {
			log.Println(err)
			return
		}
		// 如果自己没有被选择到，直接返回
		if selectedAppID != appID {
			log.Println("独占锁失败，被占有ID：", selectedAppID)
			return
		}
		// 如果自己被选择到了，执行这个定时任务
		log.Println("独占锁成功，占有ID：", selectedAppID)
		err = cronCmd.ExecuteContext(ctx)
		if err != nil {
			log.Println(err)
		}
	})
}
```

绑定业务时添加定时任务命令， `app/console/kernel.go` ：

```go
// 绑定业务的命令（业务定义的命令我们使用 `app/console/kernel.go` 中的 `AddAppCommand`进行挂载）
func AddAppCommand(rootCmd *cobra.Command) {
	...
	// 启动一个分布式任务调度，调度的服务名称为init_func_for_test，
	// 每个节点每5s调用一次Foo命令，抢占到了调度任务的节点将抢占锁持续挂载2s才释放
	rootCmd.AddDistributedCronCommand("foo_func_for_test",
		"*/5 * * * * *", demo.FooCommand, 2*time.Second)
}
```

### 代码验证

启动多个进程运行 `./gob cron start` ，同一时间只有一个抢到锁并执行。

## 15、16、配置和环境：配置服务中的设计思路

### 环境变量服务

#### 目标

可以读取到配置的环境变量，赋值到系统内，实现配置化，并且区分运行环境。

#### 如何实现

使用 `.env` 文件来设置默认环境变量。并且通过 os 标准库的 `os.Environ()` 获取环境变量。

#### 代码实现

`config` 文件划分：`dev/test/prod`。

服务定义： `framework/contract/env.go`：

```go
const (
	// EnvProd 代表生产环境
	EnvProd = "prod"
	// EnvTest 代表测试环境
	EnvTest = "test"
	// EnvDev 代表开发环境
	EnvDev = "dev"
	// EnvKey 是环境变量服务字符串凭证
	EnvKey = "gob:env"
)

// Env 定义环境变量服务
type Env interface {
	// AppEnv 获取当前的环境，建议分为 dev/test/prod
	AppEnv() string
	// IsExist 判断一个环境变量是否有被设置
	IsExist(string) bool
	// Get 获取某个环境变量，如果没有设置，返回""
	Get(string) string
	// All 获取所有的环境变量，.env 和运行环境变量融合后结果
	All() map[string]string
}
```

服务提供： `framework/provider/env/provider.go`：

```go
// EnvProvider 提供App的具体实现方法
type EnvProvider struct {
	Folder string
}
var _ framework.ServiceProvider = (*EnvProvider)(nil)

// Register 注册 GobAppService 方法
func (provider *EnvProvider) Register(container framework.Container) framework.NewInstance {
	return NewGobEnvService
}
// Boot 启动调用
func (provider *EnvProvider) Boot(container framework.Container) error {
	app := container.MustMake(contract.AppKey).(contract.App)
	provider.Folder = app.BaseFolder()
	return nil
}
// IsDefer 是否延迟初始化
func (provider *EnvProvider) IsDefer() bool {
	return false
}
// Params 获取初始化参数
func (provider *EnvProvider) Params(container framework.Container) []interface{} {
	return []interface{}{provider.Folder}
}
// Name 获取字符串凭证
func (provider *EnvProvider) Name() string {
	return contract.EnvKey
}
```

具体实现： `framework/provider/env/service.go`：

```go
// GobEnv 是 Env 的具体实现
type GobEnv struct {
	folder string            // 代表.env所在的目录
	maps   map[string]string // 保存所有的环境变量
}

// NewGobEnv 有一个参数，.env文件所在的目录
// example: NewGobEnv("/envfolder/") 会读取文件: /envfolder/.env
// .env的文件格式 FOO_ENV=BAR
func NewGobEnvService(params ...interface{}) (interface{}, error) {
	if len(params) != 1 {
		return nil, errors.New("NewGobEnv param error")
	}

	// 读取folder文件
	folder := params[0].(string)

	// 实例化
	gobEnv := &GobEnv{
		folder: folder,
		// 实例化环境变量，APP_ENV默认设置为开发环境
		maps: map[string]string{"APP_ENV": contract.EnvDev},
	}

	// 解析 folder/.env文件
	filePath := path.Join(folder, ".env")
	// 读取.env文件, 不管任意失败，都不影响后续

	// 打开文件.env
	file, err := os.Open(filePath)
	if err == nil {
		defer file.Close()

		// 读取文件
		br := bufio.NewReader(file)
		for {
			// 按照行进行读取
			line, _, c := br.ReadLine()
			if c == io.EOF {
				break
			}
			// 按照等号解析
			s := bytes.SplitN(line, []byte{'='}, 2)
			// 如果不符合规范，则过滤
			if len(s) < 2 {
				continue
			}
			// 保存map
			key := string(s[0])
			val := string(s[1])
			gobEnv.maps[key] = val
		}
	}

	// 获取当前程序的环境变量，并且覆盖.env文件下的变量
	for _, e := range os.Environ() {
		pair := strings.SplitN(e, "=", 2)
		if len(pair) < 2 {
			continue
		}
		gobEnv.maps[pair[0]] = pair[1]
	}
	// 返回实例
	return gobEnv, nil
}

// AppEnv 获取表示当前APP环境的变量APP_ENV
func (en *GobEnv) AppEnv() string {
	return en.Get("APP_ENV")
}

// IsExist 判断一个环境变量是否有被设置
func (en *GobEnv) IsExist(key string) bool {
	_, ok := en.maps[key]
	return ok
}

// Get 获取某个环境变量，如果没有设置，返回""
func (en *GobEnv) Get(key string) string {
	if val, ok := en.maps[key]; ok {
		return val
	}
	return ""
}

// All 获取所有的环境变量，.env和运行环境变量融合后结果
func (en *GobEnv) All() map[string]string {
	return en.maps
}
```

创建相关命令， `framework/command/env.go`

```go
// initEnvCommand 获取env相关的命令
func initEnvCommand() *cobra.Command {
	envCommand.AddCommand(envListCommand)
	return envCommand
}
// envCommand 获取当前的App环境
var envCommand = &cobra.Command{
	Use:   "env",
	Short: "获取当前的App环境",
	Run: func(c *cobra.Command, args []string) {
		// 获取env环境
		container := c.GetContainer()
		envService := container.MustMake(contract.EnvKey).(contract.Env)
		// 打印环境
		fmt.Println("environment:", envService.AppEnv())
	},
}
// envListCommand 获取所有的App环境变量
var envListCommand = &cobra.Command{
	Use:   "list",
	Short: "获取所有的环境变量",
	Run: func(c *cobra.Command, args []string) {
		// 获取env环境
		container := c.GetContainer()
		envService := container.MustMake(contract.EnvKey).(contract.Env)
		envs := envService.All()
		outs := [][]string{}
		for k, v := range envs {
			outs = append(outs, []string{k, v})
		}
		util.PrettyPrint(outs)
	},
}
```

挂载并绑定：

```go
// `main.go` 增加：
// 绑定 环境变量 服务提供者
container.Bind(&env.EnvProvider{})

// `framework/command/kernel.go` 增加：
// 挂载 环境变量 命令
root.AddCommand(initEnvCommand())
```

#### 代码验证

控制台验证：

```go
./gob env   // 也可以： go run . env
// 控制台输出：environment:dev

APP_ENV=testing ./gob env
// 控制台输出：environment:test
```

单测编写，这里引入了 [convey](github.com/smartystreets/goconvey/convey) 测试库，`framework/provider/env/provider_test.go`：

```go
import (
	// ...
	. "github.com/smartystreets/goconvey/convey"
)
func TestGobEnvProvider(t *testing.T) {
	Convey("test gob env normal case", t, func() {
		basePath := tests.BasePath
		c := framework.NewGobContainer()
		sp := &app.GobAppProvider{BaseFolder: basePath}

		err := c.Bind(sp)
		So(err, ShouldBeNil)

		sp2 := &EnvProvider{}
		err = c.Bind(sp2)
		So(err, ShouldBeNil)

		envServ := c.MustMake(contract.EnvKey).(contract.Env)
		So(envServ.AppEnv(), ShouldEqual, "dev")
		// So(envServ.Get("DB_HOST"), ShouldEqual, "127.0.0.1")
		// So(envServ.AppDebug(), ShouldBeTrue)
	})
}
```

### 配置服务

#### 目标

实现读取配置文件，并且支持热更新功能

#### 如何实现

通过 [go-yaml](https://github.com/go-yaml/yaml) 库读取 yaml 配置文件，并且利用环境变量替换掉配置文件中的占位符 `env(*)`。

并且读取配置时更新 `appService` 中的值。

使用 [fsnotify](https://github.com/fsnotify/fsnotify) 库监控文件，实现热更新

> 本节代码额外引入了：[mapstructure](github.com/mitchellh/mapstructure) 库、[errors](github.com/pkg/errors) 库、[pretty](github.com/kr/pretty) 库

#### 代码实现

##### 读取配置

服务定义， `framework/contract/config.go` ：

```go
const (
	// ConfigKey 是配置服务字符串凭证
	ConfigKey = "gob:config"
)

// Config 定义了配置文件服务，读取配置文件，支持点分割的路径读取
// 例如: .Get("app.name") 表示从 app 文件中读取 name 属性
// 建议使用 yaml 属性, https://yaml.org/spec/1.2/spec.html
type Config interface {
	// IsExist 检查一个属性是否存在
	IsExist(key string) bool
	// Get 获取一个属性值
	Get(key string) interface{}
	// GetBool 获取一个 bool 属性
	GetBool(key string) bool
	// GetInt 获取一个 int 属性
	GetInt(key string) int
	// GetFloat64 获取一个 float64 属性
	GetFloat64(key string) float64
	// GetTime 获取一个 time 属性
	GetTime(key string) time.Time
	// GetString 获取一个 string 属性
	GetString(key string) string
	// GetIntSlice 获取一个 int 数组属性
	GetIntSlice(key string) []int
	// GetStringSlice 获取一个 string 数组
	GetStringSlice(key string) []string
	// GetStringMap 获取一个 string 为 key，interface 为 val 的 map
	GetStringMap(key string) map[string]interface{}
	// GetStringMapString 获取一个 string 为 key，string 为 val 的 map
	GetStringMapString(key string) map[string]string
	// GetStringMapStringSlice 获取一个 string 为 key，数组 string 为 val 的 map
	GetStringMapStringSlice(key string) map[string][]string
	// Load 加载配置到某个对象
	Load(key string, val interface{}) error
}
```

服务提供， `provider/config/provider.go` ：

```go
// ConfigProvider 服务提供者具体实现方法
type ConfigProvider struct {}
var _ framework.ServiceProvider = (*ConfigProvider)(nil)

// Register 注册 GobAppService 方法
func (provider *ConfigProvider) Register(container framework.Container) framework.NewInstance {
	return NewGobConfigService
}
// Boot 启动调用
func (provider *ConfigProvider) Boot(container framework.Container) error {
	return nil
}
// IsDefer 是否延迟初始化
func (provider *ConfigProvider) IsDefer() bool {
	return false
}
// Params 获取初始化参数
func (provider *ConfigProvider) Params(container framework.Container) []interface{} {
	appService := container.MustMake(contract.AppKey).(contract.App)
	envService := container.MustMake(contract.EnvKey).(contract.Env)
	env := envService.AppEnv()
	// 配置文件夹地址
	configFolder := appService.ConfigFolder()
	envFolder := filepath.Join(configFolder, env)
	return []interface{}{container, envFolder, envService.All()}
}
// Name 获取字符串凭证
func (provider *ConfigProvider) Name() string {
	return contract.ConfigKey
}
```

服务实现， `provider/config/service.go` ：

```go
// ConfigService 是 Config 的具体实现
type ConfigService struct {
	c        framework.Container    // 容器
	folder   string                 // 文件夹
	keyDelim string                 // 路径的分隔符，默认为点
	lock     sync.RWMutex           // 配置文件读写锁
	envMaps  map[string]string      // 所有的环境变量
	confMaps map[string]interface{} // 配置文件结构，key为文件名
	confRaws map[string][]byte      // 配置文件的原始信息
}

var _ contract.Config = (*ConfigService)(nil)

// NewGobConfigService 初始化Config方法
func NewGobConfigService(params ...interface{}) (interface{}, error) {
	container := params[0].(framework.Container)
	envFolder := params[1].(string)
	envMaps := params[2].(map[string]string)

	// 检查文件夹是否存在
	if _, err := os.Stat(envFolder); os.IsNotExist(err) {
		return nil, errors.New("folder " + envFolder + " not exist: " + err.Error())
	}

	// 实例化
	gobConf := &ConfigService{
		c:        container,
		folder:   envFolder,
		envMaps:  envMaps,
		confMaps: map[string]interface{}{},
		confRaws: map[string][]byte{},
		keyDelim: ".",
		lock:     sync.RWMutex{},
	}

	// 读取每个文件
	files, err := ioutil.ReadDir(envFolder)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for _, file := range files {
		fileName := file.Name()
		err := gobConf.loadConfigFile(envFolder, fileName)
		if err != nil {
			log.Println(err)
			continue
		}
	}

	// 监控文件夹文件
	watch, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, err
	}
	if err = watch.Add(envFolder); err != nil {
		return nil, err
	}
	go func() {
		defer func() {
			if err := recover(); err != nil {
				fmt.Println(err)
			}
		}()
		for {
			select {
			case ev := <-watch.Events:
				// 判断事件发生的类型
				// Create 创建
				// Write 写入
				// Remove 删除
				path, _ := filepath.Abs(ev.Name)
				index := strings.LastIndex(path, string(os.PathSeparator))
				folder := path[:index]
				fileName := path[index+1:]

				if ev.Op&fsnotify.Create == fsnotify.Create {
					log.Println("创建文件 : ", ev.Name)
					gobConf.loadConfigFile(folder, fileName)
				}
				if ev.Op&fsnotify.Write == fsnotify.Write {
					log.Println("写入文件 : ", ev.Name)
					gobConf.loadConfigFile(folder, fileName)
				}
				if ev.Op&fsnotify.Remove == fsnotify.Remove {
					log.Println("删除文件 : ", ev.Name)
					gobConf.removeConfigFile(folder, fileName)
				}
			case err := <-watch.Errors:
				log.Println("error : ", err)
				return
			}
		}
	}()
	return gobConf, nil
}

// 读取某个配置文件
func (conf *ConfigService) loadConfigFile(folder string, file string) error {
	conf.lock.Lock()
	defer conf.lock.Unlock()
	//  判断文件是否以yaml或者yml作为后缀
	s := strings.Split(file, ".")
	if len(s) == 2 && (s[1] == "yaml" || s[1] == "yml") {
		name := s[0]
		// 读取文件内容
		bf, err := ioutil.ReadFile(filepath.Join(folder, file))
		if err != nil {
			return err
		}
		// 直接针对文本做环境变量的替换
		bf = replace(bf, conf.envMaps)
		// 解析对应的文件
		c := map[string]interface{}{}
		if err := yaml.Unmarshal(bf, &c); err != nil {
			return err
		}
		conf.confMaps[name] = c
		conf.confRaws[name] = bf

		// 读取app.path中的信息，更新 app 对应的 folder
		if name == "app" && conf.c.IsBind(contract.AppKey) {
			if p, ok := c["path"]; ok {
				appService := conf.c.MustMake(contract.AppKey).(contract.App)
				appService.LoadAppConfig(cast.ToStringMapString(p))
			}
		}
	}
	return nil
}

// 删除文件的操作
func (conf *ConfigService) removeConfigFile(folder string, file string) error {
	conf.lock.Lock()
	defer conf.lock.Unlock()
	s := strings.Split(file, ".")
	// 只有yaml或者yml后缀才执行
	if len(s) == 2 && (s[1] == "yaml" || s[1] == "yml") {
		name := s[0]
		// 删除内存中对应的key
		delete(conf.confRaws, name)
		delete(conf.confMaps, name)
	}
	return nil
}

// replace 表示使用环境变量maps替换context中的env(xxx)的环境变量
func replace(content []byte, maps map[string]string) []byte {
	if maps == nil {
		return content
	}
	// 直接使用ReplaceAll替换。这个性能可能不是最优，但是配置文件加载，频率是比较低的，可以接受
	for key, val := range maps {
		reKey := "env(" + key + ")"
		content = bytes.ReplaceAll(content, []byte(reKey), []byte(val))
	}
	return content
}

// 查找某个路径的配置项
func searchMap(source map[string]interface{}, path []string) interface{} {
	if len(path) == 0 {
		return source
	}
	// 判断是否有下个路径
	next, ok := source[path[0]]
	if ok {
		// 判断这个路径是否为1
		if len(path) == 1 {
			return next
		}
		// 判断下一个路径的类型
		switch next.(type) {
		case map[interface{}]interface{}:
			// 如果是interface的map，使用cast进行下value转换
			return searchMap(cast.ToStringMap(next), path[1:])
		case map[string]interface{}:
			// 如果是map[string]，直接循环调用
			return searchMap(next.(map[string]interface{}), path[1:])
		default:
			// 否则的话，返回nil
			return nil
		}
	}
	return nil
}

// 通过path获取某个元素
func (conf *ConfigService) find(key string) interface{} {
	conf.lock.RLock()
	defer conf.lock.RUnlock()
	return searchMap(conf.confMaps, strings.Split(key, conf.keyDelim))
}

// IsExist check setting is exist
func (conf *ConfigService) IsExist(key string) bool {
	return conf.find(key) != nil
}

// Get 获取某个配置项
func (conf *ConfigService) Get(key string) interface{} {
	return conf.find(key)
}

// GetBool 获取bool类型配置
func (conf *ConfigService) GetBool(key string) bool {
	return cast.ToBool(conf.find(key))
}

... // 其他Get*方法

// Load a config to a struct, val should be an pointer
func (conf *ConfigService) Load(key string, val interface{}) error {
	decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		TagName: "yaml",
		Result:  val,
	})
	if err != nil {
		return err
	}

	return decoder.Decode(conf.find(key))
}
```

##### 读取配置替换 app 配置

`framework/contract/app.go` 新增：

```go
type App interface {
	... 
	// LoadAppConfig 加载新的AppConfig，key为对应的函数转为小写下划线，比如ConfigFolder => config_folder
	LoadAppConfig(kv map[string]string)
}
```

`framework/provider/app/service.go` 新增：

```go
// 将 GobApp 增加一个 `configMap` 字段：
// GobApp 代表gob框架的App实现
type GobApp struct {
   ...
   configMap map[string]string // 配置加载
}

// 同时为 GobApp 增加 `LoadAppConfig` 方法，用于读取配置文件中的信息：
// LoadAppConfig 加载配置map
func (app *GobApp) LoadAppConfig(kv map[string]string) {
   for key, val := range kv {
      app.configMap[key] = val
   }
}

// 队友app方法全部改为先读取配置文件
// ConfigFolder  表示配置文件地址
func (app GobAppService) ConfigFolder() string {
	if val, ok := app.configMap["config_folder"]; ok {
		return val
	}
	return filepath.Join(app.BaseFolder(), "config")
}
... // 其他方法
```

加载时机，上面服务实现已经有了的 `provider/config/service.go` ：

```go
// 读取某个配置文件
func (conf *ConfigService) loadConfigFile(folder string, file string) error {
	...
		...
		// 读取app.path中的信息，更新 app 对应的 folder
		if name == "app" && conf.c.IsBind(contract.AppKey) {
			if p, ok := c["path"]; ok {
				appService := conf.c.MustMake(contract.AppKey).(contract.App)
				appService.LoadAppConfig(cast.ToStringMapString(p))
			}
		}
	}
	return nil
}
```

##### 配置文件热更新

监控文件回调，上面服务实现已经有了的 `provider/config/service.go` ：

```go
// NewGobConfigService 初始化Config方法
func NewGobConfigService(params ...interface{}) (interface{}, error) {
	...
	// 监控文件夹文件
	watch, err := fsnotify.NewWatcher()
	...
	go func() {
		defer func() {
			if err := recover(); err != nil {
				fmt.Println(err)
			}
		}()
		for {
			select {
			case ev := <-watch.Events:
				path, _ := filepath.Abs(ev.Name)
				index := strings.LastIndex(path, string(os.PathSeparator))
				folder := path[:index]
				fileName := path[index+1:]
				if ev.Op&fsnotify.Create == fsnotify.Create {
					log.Println("创建文件 : ", ev.Name)
					gobConf.loadConfigFile(folder, fileName)
				}
				if ev.Op&fsnotify.Write == fsnotify.Write {
					log.Println("写入文件 : ", ev.Name)
					gobConf.loadConfigFile(folder, fileName)
				}
				if ev.Op&fsnotify.Remove == fsnotify.Remove {
					log.Println("删除文件 : ", ev.Name)
					gobConf.removeConfigFile(folder, fileName)
				}
			case err := <-watch.Errors:
				log.Println("error : ", err)
				return
			}
		}
	}()
	return gobConf, nil
}
```

并且 `find` 函数加读锁，`loadConfigFlie` 函数加写锁。

##### 挂载并绑定命令

```go
// initConfigCommand 获取配置相关的命令
func initConfigCommand() *cobra.Command {
	configCommand.AddCommand(configGetCommand)
	return configCommand
}

// envCommand 获取当前的App环境
var configCommand = &cobra.Command{
	Use:   "config",
	Short: "获取配置相关信息",
	RunE: func(c *cobra.Command, args []string) error {
		if len(args) == 0 {
			c.Help()
		}
		return nil
	},
}

// envListCommand 获取所有的App环境变量
var configGetCommand = &cobra.Command{
	Use:   "get",
	Short: "获取某个配置信息",
	RunE: func(c *cobra.Command, args []string) error {
		container := c.GetContainer()
		configService := container.MustMake(contract.ConfigKey).(contract.Config)
		if len(args) != 1 {
			fmt.Println("参数错误")
			return nil
		}
		configPath := args[0]
		val := configService.Get(configPath)
		if val == nil {
			fmt.Println("配置路径 ", configPath, " 不存在")
			return nil
		}
		fmt.Printf("%# v\n", pretty.Formatter(val))
		return nil
	},
}
```

```go
// `main.go` 增加：
// 绑定 配置 服务提供者
container.Bind(&config.ConfigProvider{})

// `framework/command/kernel.go` 增加：
// 挂载 配置 命令  
root.AddCommand(initConfigCommand())
```

#### 代码验证

配置简单定义， `app/config/dev/database.yaml` ：

```yaml
mysql:
  hostname: 127.0.0.1
  username: test
  password: env(DB_PASSWORD)
  timeout: 1
```

业务目录下的 `module/demo/api.go`，替换其中 `/demo/demo` 对应的路由方法：

```go
func (api *DemoApi) Demo(c *gin.Context) {
   // 获取password
   configService := c.MustMake(contract.ConfigKey).(contract.Config)
   password := configService.GetString("database.mysql.password")
   // 打印出来
   c.JSON(200, password)
}
```

最后使用命令行 `./gob app start` 启动服务，访问测试；

注入变量后再次访问测试：

```go
DB_PASSWORD=123 ./gob app start
```

不停止进程，更新 `database.yaml` 文件后，再次访问测试。

控制台验证：

```go
./gob config get database   // 也可以： go run . config get database
// 控制台输出：database.yaml 的相关打印输出
```

## 17、日志

解决三个问题：什么样的日志需要输出？日志输出哪些内容？日志输出到哪里？

### 如何实现

#### 日志级别

参考 Linux 的 [syslog](https://datatracker.ietf.org/doc/html/rfc5424) 、Java 的 [log4j](https://logging.apache.org/log4j/2.x/)，调整归并为下列七种日志级别：

- panic，表示会导致整个程序出现崩溃的日志信息
- fatal，表示会导致当前这个请求出现提前终止的错误信息
- error，表示出现错误，但是不一定影响后续请求逻辑的错误信息
- warn，表示出现错误，但是一定不影响后续请求逻辑的报警信息
- info，表示正常的日志信息输出
- debug，表示在调试状态下打印出来的日志信息
- trace，表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息

#### 日志格式

一般分为四个部分：

- 日志级别，输出当前日志的级别信息。
- 日志时间，输出当前日志的打印时间。
- 日志简要信息，输出当前日志的简要描述信息，一句话说明日志错误。
- 日志上下文字段，输出当前日志的附带信息。这些字段代表日志打印的上下文。

例如：

```go
[Info]	2024-01-10T20:44:10+08:00	"demo test logger"	map[api:demo/demo cspan_id: parent_id: span_id:cmf926hfq7kkqh35eno0 trace_id:cmf926hfq7kkqh35enng password:666]
```

#### 日志切割

[file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs) 库

#### 日志输出

输出到 `io.Writer` 管道，每个应用具体再实现。

#### 全链路

参考 Google Dapper 中的链路 ID 定义， [来自 Google Dapper 论文的见解](https://medium.com/100paperschallenge/insights-from-paper-google-dapper-a-large-scale-distributed-systems-tracing-infrastructure-1f5a448ca000) 。

#### ID

引入 `"github.com/rs/xid"` 全局唯一标识符（GUID）库。

### 代码实现

#### 日志服务

服务定义：`framework/contract/log.go`：

```go
// LogKey 定义字符串凭证
const LogKey = "gob:log"

type LogLevel uint32

const (
	// UnknownLevel 表示未知的日志级别
	UnknownLevel LogLevel = iota
	// PanicLevel level, panic 表示会导致整个程序出现崩溃的日志信息
	PanicLevel
	// FatalLevel level. fatal 表示会导致当前这个请求出现提前终止的错误信息
	FatalLevel
	// ErrorLevel level. error 表示出现错误，但是不一定影响后续请求逻辑的错误信息
	ErrorLevel
	// WarnLevel level. warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息
	WarnLevel
	// InfoLevel level. info 表示正常的日志信息输出
	InfoLevel
	// DebugLevel level. debug 表示在调试状态下打印出来的日志信息
	DebugLevel
	// TraceLevel level. trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息
	TraceLevel
)

// CtxFielder 定义了从context中获取信息的方法
type CtxFielder func(ctx context.Context) map[string]interface{}

// Formatter 定义了将日志信息组织成字符串的通用方法
type Formatter func(level LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error)

// Log define interface for log
type Log interface {
	// Panic 表示会导致整个程序出现崩溃的日志信息
	Panic(ctx context.Context, msg string, fields map[string]interface{})
	// Fatal 表示会导致当前这个请求出现提前终止的错误信息
	Fatal(ctx context.Context, msg string, fields map[string]interface{})
	// Error 表示出现错误，但是不一定影响后续请求逻辑的错误信息
	Error(ctx context.Context, msg string, fields map[string]interface{})
	// Warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息
	Warn(ctx context.Context, msg string, fields map[string]interface{})
	// Info 表示正常的日志信息输出
	Info(ctx context.Context, msg string, fields map[string]interface{})
	// Debug 表示在调试状态下打印出来的日志信息
	Debug(ctx context.Context, msg string, fields map[string]interface{})
	// Trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息
	Trace(ctx context.Context, msg string, fields map[string]interface{})
	// SetLevel 设置日志级别
	SetLevel(level LogLevel)
	// SetCtxFielder 从context中获取上下文字段field
	SetCtxFielder(handler CtxFielder)
	// SetFormatter 设置输出格式
	SetFormatter(formatter Formatter)
	// SetOutput 设置输出管道
	SetOutput(out io.Writer)
}
```

服务提供，`framework/provider/log/provider.go`：

```go
// LogProvider 服务提供者具体实现方法
type LogProvider struct {
	// 运行模式
	Driver string
	// 日志级别
	Level contract.LogLevel
	// 日志输出格式方法
	Formatter contract.Formatter
	// 日志context上下文信息获取函数
	CtxFielder contract.CtxFielder
	// 日志输出信息
	Output io.Writer
}
var _ framework.ServiceProvider = (*LogProvider)(nil)

// Register 注册 GobAppService 方法
func (provider *LogProvider) Register(container framework.Container) framework.NewInstance {
	if provider.Driver == "" {
		configContainer, err := container.Make(contract.ConfigKey)
		if err != nil {
			// 默认使用console
			return services.NewConsoleLogService
		}
		config := configContainer.(contract.Config)
		provider.Driver = strings.ToLower(config.GetString("log.driver"))
	}
	// 根据driver的配置项确定
	switch provider.Driver {
	case "single":
		return services.NewSingleLogService
	case "rotate":
		return services.NewRotateLogService
	case "console":
		return services.NewConsoleLogService
	case "custom":
		return services.NewCustomLogService
	default:
		return services.NewConsoleLogService
	}
}

// Boot 启动调用
func (provider *LogProvider) Boot(container framework.Container) error {
	return nil
}
// IsDefer 是否延迟初始化
func (provider *LogProvider) IsDefer() bool {
	return false
}

// Params 获取初始化参数
func (provider *LogProvider) Params(container framework.Container) []interface{} {
	// 获取configService
	configService := container.MustMake(contract.ConfigKey).(contract.Config)
	// 设置参数formatter
	if provider.Formatter == nil {
		provider.Formatter = formatter.TextFormatter
		if configService.IsExist("log.formatter") {
			v := configService.GetString("log.formatter")
			if v == "json" {
				provider.Formatter = formatter.JsonFormatter
			} else if v == "text" {
				provider.Formatter = formatter.TextFormatter
			}
		}
	}
	// 设置参数level
	if provider.Level == contract.UnknownLevel {
		provider.Level = contract.InfoLevel
		if configService.IsExist("log.level") {
			provider.Level = logLevel(configService.GetString("log.level"))
		}
	}
	// 定义5个参数
	return []interface{}{container, provider.Level, provider.CtxFielder, provider.Formatter, provider.Output}
}

// Name 获取字符串凭证
func (provider *LogProvider) Name() string {
	return contract.LogKey
}

// logLevel get level from string
func logLevel(config string) contract.LogLevel {
	switch strings.ToLower(config) {
	case "panic":
		return contract.PanicLevel
	case "fatal":
		return contract.FatalLevel
	case "error":
		return contract.ErrorLevel
	case "warn":
		return contract.WarnLevel
	case "info":
		return contract.InfoLevel
	case "debug":
		return contract.DebugLevel
	case "trace":
		return contract.TraceLevel
	}
	return contract.UnknownLevel
}
```

服务实现，`framework/provider/log/services/log.go`：

```go
// LogService 的通用实例
type LogService struct {
	// 五个必要的参数
	c          framework.Container // 容器
	level      contract.LogLevel   // 日志级别
	formatter  contract.Formatter  // 日志格式化方法
	ctxFielder contract.CtxFielder // ctx获取上下文字段
	output     io.Writer           // 输出
}

// IsLevelEnable 判断这个级别是否可以打印
func (log *LogService) IsLevelEnable(level contract.LogLevel) bool {
	return level <= log.level
}

// logf 为打印日志的核心函数
func (log *LogService) logf(level contract.LogLevel, ctx context.Context, msg string, fields map[string]interface{}) error {
	// 先判断日志级别
	if !log.IsLevelEnable(level) {
		return nil
	}
	// 使用ctxFielder 获取context中的信息
	fs := fields
	if log.ctxFielder != nil {
		t := log.ctxFielder(ctx)
		if t != nil {
			for k, v := range t {
				fs[k] = v
			}
		}
	}
	//如果绑定了trace服务，获取trace信息
	if log.c.IsBind(contract.TraceKey) {
		tracer := log.c.MustMake(contract.TraceKey).(contract.Trace)
		tc := tracer.GetTrace(ctx)
		if tc != nil {
			maps := tracer.ToMap(tc)
			for k, v := range maps {
				fs[k] = v
			}
		}
	}
	// 将日志信息按照formatter序列化为字符串
	if log.formatter == nil {
		log.formatter = formatter.TextFormatter
	}
	ct, err := log.formatter(level, time.Now(), msg, fs)
	if err != nil {
		return err
	}
	// 如果是panic级别，则使用log进行panic
	if level == contract.PanicLevel {
		pkgLog.Panicln(string(ct))
		return nil
	}
	// 通过output进行输出
	log.output.Write(ct)
	log.output.Write([]byte("\r\n"))
	return nil
}

// Panic 输出panic的日志信息
func (log *LogService) Panic(ctx context.Context, msg string, fields map[string]interface{}) {
	log.logf(contract.PanicLevel, ctx, msg, fields)
}

... // 其他 level 输出日志信息

// SetLevel set log level, and higher level will be recorded
func (log *LogService) SetLevel(level contract.LogLevel) {
	log.level = level
}
// SetCxtFielder will get fields from context
func (log *LogService) SetCtxFielder(handler contract.CtxFielder) {
	log.ctxFielder = handler
}
// SetFormatter will set formatter handler will covert data to string for recording
func (log *LogService) SetFormatter(formatter contract.Formatter) {
	log.formatter = formatter
}
// SetOutput 设置output
func (log *LogService) SetOutput(output io.Writer) {
	log.output = output
}
```

其他继承 `log.go` 的日志输出方式，例如：`framework/provider/log/services/rotate.go`：

```go
// RotateLogService 代表会进行切割的日志文件存储
type RotateLogService struct {
	LogService
	// 日志文件存储目录
	folder string
	// 日志文件名
	file string
}

// NewRotateLogService 实例化 RotateLogService
func NewRotateLogService(params ...interface{}) (interface{}, error) {
	// 参数解析
	c := params[0].(framework.Container)
	level := params[1].(contract.LogLevel)
	ctxFielder := params[2].(contract.CtxFielder)
	formatter := params[3].(contract.Formatter)

	appService := c.MustMake(contract.AppKey).(contract.App)
	configService := c.MustMake(contract.ConfigKey).(contract.Config)

	// 从配置文件中获取folder信息，否则使用默认的LogFolder文件夹
	folder := appService.LogFolder()
	if configService.IsExist("log.folder") {
		folder = configService.GetString("log.folder")
	}
	// 如果folder不存在，则创建
	if !util.Exists(folder) {
		os.MkdirAll(folder, os.ModePerm)
	}
	// 从配置文件中获取file信息，否则使用默认的gob.log
	file := "gob.log"
	if configService.IsExist("log.file") {
		file = configService.GetString("log.file")
	}
	// 从配置文件获取date_format信息
	dateFormat := "%Y%m%d%H"
	if configService.IsExist("log.date_format") {
		dateFormat = configService.GetString("log.date_format")
	}
	linkName := rotatelogs.WithLinkName(filepath.Join(folder, file))
	options := []rotatelogs.Option{linkName}
	// 从配置文件获取rotate_count信息
	if configService.IsExist("log.rotate_count") {
		rotateCount := configService.GetInt("log.rotate_count")
		options = append(options, rotatelogs.WithRotationCount(uint(rotateCount)))
	}
	// 从配置文件获取rotate_size信息
	if configService.IsExist("log.rotate_size") {
		rotateSize := configService.GetInt("log.rotate_size")
		options = append(options, rotatelogs.WithRotationSize(int64(rotateSize)))
	}
	// 从配置文件获取max_age信息
	if configService.IsExist("log.max_age") {
		if maxAgeParse, err := time.ParseDuration(configService.GetString("log.max_age")); err == nil {
			options = append(options, rotatelogs.WithMaxAge(maxAgeParse))
		}
	}
	// 从配置文件获取rotate_time信息
	if configService.IsExist("log.rotate_time") {
		if rotateTimeParse, err := time.ParseDuration(configService.GetString("log.rotate_time")); err == nil {
			options = append(options, rotatelogs.WithRotationTime(rotateTimeParse))
		}
	}
	// 设置基础信息
	log := &RotateLogService{}
	log.SetLevel(level)
	log.SetCtxFielder(ctxFielder)
	log.SetFormatter(formatter)
	log.folder = folder
	log.file = file

	w, err := rotatelogs.New(fmt.Sprintf("%s.%s", filepath.Join(log.folder, log.file), dateFormat), options...)
	if err != nil {
		return nil, errors.Wrap(err, "new rotatelogs error")
	}
	log.SetOutput(w)
	log.c = c
	return log, nil
}
```

这里省略 `services` 文件夹里的 `console.go`、`single.go`、`custom.go`；以及 `formatter` 里的 `json.go`、`text.go`、`prefix.go`。

#### 全链路服务

服务定义：`framework/contract/trace.go`：

```go
const TraceKey = "gob:trace"
const (
	TraceKeyTraceID  = "trace_id"
	TraceKeySpanID   = "span_id"
	TraceKeyCspanID  = "cspan_id"
	TraceKeyParentID = "parent_id"
	TraceKeyMethod   = "method"
	TraceKeyCaller   = "caller"
	TraceKeyTime     = "time"
)

// Trace define struct according Google Dapper
type TraceContext struct {
	TraceID  string // traceID global unique
	ParentID string // 父节点SpanID
	SpanID   string // 当前节点SpanID
	CspanID  string // 子节点调用的SpanID, 由调用方指定

	Annotation map[string]string // 标记各种信息
}
type Trace interface {
	// WithTrace register new trace to context
	WithTrace(c context.Context, trace *TraceContext) context.Context
	// GetTrace From trace context
	GetTrace(c context.Context) *TraceContext
	// NewTrace generate a new trace
	NewTrace() *TraceContext
	// StartSpan generate cspan for child call
	StartSpan(trace *TraceContext) *TraceContext
	// ToMap traceContext to map for logger
	ToMap(trace *TraceContext) map[string]string
	// ExtractHTTP GetTrace By Http
	ExtractHTTP(req *http.Request) *TraceContext
	// InjectHTTP Set Trace to Http
	InjectHTTP(req *http.Request, trace *TraceContext) *http.Request
}
```

服务提供，`framework/provider/trace/provider.go`：

```go
// TraceProvider 服务提供者具体实现方法
type TraceProvider struct {
	c framework.Container
}
var _ framework.ServiceProvider = (*TraceProvider)(nil)

// Register 注册方法
func (provider *TraceProvider) Register(container framework.Container) framework.NewInstance {
	return NewTraceService
}
// Boot 启动调用
func (provider *TraceProvider) Boot(container framework.Container) error {
	provider.c = container
	return nil
}
// IsDefer 是否延迟初始化
func (provider *TraceProvider) IsDefer() bool {
	return false
}
// Params 获取初始化参数
func (provider *TraceProvider) Params(container framework.Container) []interface{} {
	return []interface{}{provider.c}
}
// Name 获取字符串凭证
func (provider *TraceProvider) Name() string {
	return contract.TraceKey
}
```

服务实现，`framework/provider/trace/service.go`：

```go
type TraceKey string
var ContextKey = TraceKey("trace-key")

// TraceService 是 TraceService 的具体实现
type TraceService struct {
	idService        contract.ID
	traceIDGenerator contract.ID
	spanIDGenerator  contract.ID
}
var _ contract.Trace = (*TraceService)(nil)

func NewTraceService(params ...interface{}) (interface{}, error) {
	c := params[0].(framework.Container)
	idService := c.MustMake(contract.IDKey).(contract.ID)
	return &TraceService{idService: idService}, nil
}
// WithTrace register new trace to context
func (t *TraceService) WithTrace(c context.Context, trace *contract.TraceContext) context.Context {
	if ginC, ok := c.(*gin.Context); ok {
		ginC.Set(string(ContextKey), trace)
		return ginC
	} else {
		newC := context.WithValue(c, ContextKey, trace)
		return newC
	}
}
// GetTrace From trace context
func (t *TraceService) GetTrace(c context.Context) *contract.TraceContext {
	if ginC, ok := c.(*gin.Context); ok {
		if val, ok2 := ginC.Get(string(ContextKey)); ok2 {
			return val.(*contract.TraceContext)
		}
	}

	if tc, ok := c.Value(ContextKey).(*contract.TraceContext); ok {
		return tc
	}
	return nil
}
// NewTrace generate a new trace
func (t *TraceService) NewTrace() *contract.TraceContext {
	var traceID, spanID string
	if t.traceIDGenerator != nil {
		traceID = t.traceIDGenerator.NewID()
	} else {
		traceID = t.idService.NewID()
	}

	if t.spanIDGenerator != nil {
		spanID = t.spanIDGenerator.NewID()
	} else {
		spanID = t.idService.NewID()
	}
	tc := &contract.TraceContext{
		TraceID:    traceID,
		ParentID:   "",
		SpanID:     spanID,
		CspanID:    "",
		Annotation: map[string]string{},
	}
	return tc
}
// ChildSpan instance a sub trace with new span id
func (t *TraceService) StartSpan(tc *contract.TraceContext) *contract.TraceContext {
	var childSpanID string
	if t.spanIDGenerator != nil {
		childSpanID = t.spanIDGenerator.NewID()
	} else {
		childSpanID = t.idService.NewID()
	}
	childSpan := &contract.TraceContext{
		TraceID:  tc.TraceID,
		ParentID: "",
		SpanID:   tc.SpanID,
		CspanID:  childSpanID,
		Annotation: map[string]string{
			contract.TraceKeyTime: time.Now().String(),
		},
	}
	return childSpan
}
// GetTrace By Http
func (t *TraceService) ExtractHTTP(req *http.Request) *contract.TraceContext {
	tc := &contract.TraceContext{}
	tc.TraceID = req.Header.Get(contract.TraceKeyTraceID)
	tc.ParentID = req.Header.Get(contract.TraceKeySpanID)
	tc.SpanID = req.Header.Get(contract.TraceKeyCspanID)
	tc.CspanID = ""

	if tc.TraceID == "" {
		tc.TraceID = t.idService.NewID()
	}
	if tc.SpanID == "" {
		tc.SpanID = t.idService.NewID()
	}
	return tc
}
// Set Trace to Http
func (t *TraceService) InjectHTTP(req *http.Request, tc *contract.TraceContext) *http.Request {
	req.Header.Add(contract.TraceKeyTraceID, tc.TraceID)
	req.Header.Add(contract.TraceKeySpanID, tc.SpanID)
	req.Header.Add(contract.TraceKeyCspanID, tc.CspanID)
	req.Header.Add(contract.TraceKeyParentID, tc.ParentID)
	return req
}
func (t *TraceService) ToMap(tc *contract.TraceContext) map[string]string {
	m := map[string]string{}
	if tc == nil {
		return m
	}
	m[contract.TraceKeyTraceID] = tc.TraceID
	m[contract.TraceKeySpanID] = tc.SpanID
	m[contract.TraceKeyCspanID] = tc.CspanID
	m[contract.TraceKeyParentID] = tc.ParentID
	
	if tc.Annotation != nil {
		for k, v := range tc.Annotation {
			m[k] = v
		}
	}
	return m
}
```

#### ID 服务

服务定义：`framework/contract/id.go`：

```go
const IDKey = "gob:id"
type ID interface {
	NewID() string
}
```

服务提供，`framework/provider/id/provider.go`：

```go
// IDProvider 服务提供者具体实现方法
type IDProvider struct{}
var _ framework.ServiceProvider = (*IDProvider)(nil)

// Register 注册方法
func (provider *IDProvider) Register(container framework.Container) framework.NewInstance {
	return NewIDService
}
// Boot 启动调用
func (provider *IDProvider) Boot(container framework.Container) error {
	return nil
}
// IsDefer 是否延迟初始化
func (provider *IDProvider) IsDefer() bool {
	return false
}
// Params 获取初始化参数
func (provider *IDProvider) Params(container framework.Container) []interface{} {
	return []interface{}{}
}
// Name 获取字符串凭证
func (provider *IDProvider) Name() string {
	return contract.IDKey
}
```

服务实现，`framework/provider/id/service.go`：

```go
import (
	"github.com/chenbihao/gob/framework/contract"
	"github.com/rs/xid" // 全局唯一标识符（GUID）
)
// IDService 是 IDService 的具体实现
type IDService struct{}
var _ contract.ID = (*IDService)(nil)

func NewIDService(params ...interface{}) (interface{}, error) {
	return &IDService{}, nil
}
func (s *IDService) NewID() string {
	return xid.New().String()
}
```

#### 全链路中间件

`framework/middleware/trace.go`：

```go
// Trace 机制，全链路ID
func Trace() gin.HandlerFunc {
	// 使用函数回调
	return func(c *gin.Context) {
		tracer := c.MustMake(contract.TraceKey).(contract.Trace)
		traceCtx := tracer.ExtractHTTP(c.Request)
		tracer.WithTrace(c, traceCtx)

		// 使用next执行具体的业务逻辑
		c.Next()
	}
}
```

注册中间件，`app/http/route.go`：

```go
// Routes 绑定业务层路由
func Routes(r *gin.Engine) {
	...
	// 使用全链路追踪
	r.Use(middleware.Trace())
	demo.Register(r) // app/http/module/demo/*
}
```

#### 绑定服务

`main.go`：

```go
	// 绑定 日志 服务提供者
	container.Bind(&log.LogProvider{})
	// 绑定 全链路支持 服务提供者
	container.Bind(&id.IDProvider{})
	container.Bind(&trace.TraceProvider{})
```

### 代码验证

配置文件，`config/dev/log.yaml`：

```go
driver: console
formatter: text
level: trace

#driver: single
#level: trace
#folder: /tmp/
#file: gob_single.log

#driver: rotate      # 切割日志
#level: trace        # 日志级别
#file: gob.log       # 保存的日志文件
#rotate_count: 10    # 最多日志文件个数
#rotate_size: 120000 # 每个日志大小
#rotate_time: "1m"   # 切割时间
#max_age: "10d"      # 文件保存时间
#date_format: "%Y-%m-%d-%H-%M" # 文件后缀格式
```

访问任意请求，控制台输出：

```go
[Info]	2024-01-10T20:44:10+08:00	"demo test logger"	map[api:demo/demo cspan_id: parent_id: password:666 span_id:cmf926hfq7kkqh35eno0 trace_id:cmf926hfq7kkqh35enng]
[GIN] 2024/01/10 - 20:44:10 | 200 |     15.4088ms |             ::1 | GET      "/demo/demo"
```

其他日志模式也能正确存储日志文件。

## 18、一体化

前后端一体化的架构方案。

将 API 层往上提，使用 Golang 替代网关的逻辑，请求先访问前端编译的静态文件，不存在再访问动态接口。

```mermaid
flowchart TD

subgraph new
_Gateway --> _HTML
end

subgraph old
Nginx --> HTML
Nginx --> API
end
```

### 如何实现

创建一个 vue 项目，

利用 gin 社区 github.com/gin-contrib 中的一个中间件 [static](https://github.com/gin-contrib/static) ，在路由中将请求路由到静态文件、动态请求。

### 代码实现

#### 创建 vue3 项目

```shell
# 安装并执行create-vue
npm create vue@latest

# 运行 `npm run dev` ；构建 `npm run build`；
```

#### 把请求路由到结果文件夹

创建中间件 `framework/middleware/static/static.go`：

```go

const INDEX = "index.html"

type ServeFileSystem interface {
	http.FileSystem
	Exists(prefix string, path string) bool
}

type localFileSystem struct {
	http.FileSystem
	root    string
	indexes bool
}

func LocalFile(root string, indexes bool) *localFileSystem {
	return &localFileSystem{
		FileSystem: gin.Dir(root, indexes),
		root:       root,
		indexes:    indexes,
	}
}

func (l *localFileSystem) Exists(prefix string, filepath string) bool {
	if p := strings.TrimPrefix(filepath, prefix); len(p) < len(filepath) {
		name := path.Join(l.root, p)
		stats, err := os.Stat(name)
		if err != nil {
			return false
		}
		if stats.IsDir() {
			if !l.indexes {
				index := path.Join(name, INDEX)
				_, err := os.Stat(index)
				if err != nil {
					return false
				}
			}
		}
		return true
	}
	return false
}

func ServeRoot(urlPrefix, root string) gin.HandlerFunc {
	return Serve(urlPrefix, LocalFile(root, false))
}

// Static returns a middleware handler that serves static files in the given directory.
func Serve(urlPrefix string, fs ServeFileSystem) gin.HandlerFunc {
	fileserver := http.FileServer(fs)
	if urlPrefix != "" {
		fileserver = http.StripPrefix(urlPrefix, fileserver)
	}
	return func(c *gin.Context) {
		if fs.Exists(urlPrefix, c.Request.URL.Path) {
			fileserver.ServeHTTP(c.Writer, c.Request)
			c.Abort()
		}
	}
}

```

应用中间件，`app/http/route.go`：

```go
// Routes 绑定业务层路由
func Routes(r *gin.Engine) {

	// /路径先去./dist目录下查找文件是否存在，找到使用文件服务提供服务
	r.Use(static.Serve("/", static.LocalFile("./gob_frontend/dist", false)))
	
	demo.Register(r) // 这个demo是业务App自定义的demo服务,位置在 `app/http/module/demo/*`
}
```

### 编译命令改造

构建命令，`framework/command/cmd_build.go`：

```go
// 前端文件夹
const frontendFolder = "./gob_frontend/"

// build相关的命令
func initBuildCommand() *cobra.Command {
	buildCommand.AddCommand(buildSelfCommand)
	buildCommand.AddCommand(buildBackendCommand)
	buildCommand.AddCommand(buildFrontendCommand)
	buildCommand.AddCommand(buildAllCommand)
	return buildCommand
}

var buildCommand = &cobra.Command{
	Use:   "build",
	Short: "编译相关命令",
	RunE: func(c *cobra.Command, args []string) error {
		if len(args) == 0 {
			c.Help()
		}
		return nil
	},
}

var buildSelfCommand = &cobra.Command{
	Use:   "self",
	Short: "编译 gob 命令",
	RunE: func(c *cobra.Command, args []string) error {
		fmt.Println("=============  后端编译开始 ============")
		path, err := exec.LookPath("go")
		if err != nil {
			log.Fatalln("请安装 go 在你的 PATH 路径下")
		}

		cmd := exec.Command(path, "build", "-o", "gob", "./")
		out, err := cmd.CombinedOutput()
		if err != nil {
			fmt.Println(string(out))
			fmt.Println("=============  后端编译失败 ============")
			return err
		}
		fmt.Println("build success please run ./gob direct")
		fmt.Println("=============  后端编译成功 ============")
		return nil
	},
}

var buildBackendCommand = &cobra.Command{
	Use:   "backend",
	Short: "使用 go 编译后端",
	RunE: func(c *cobra.Command, args []string) error {
		return buildSelfCommand.RunE(c, args)
	},
}

var buildFrontendCommand = &cobra.Command{
	Use:   "frontend",
	Short: "使用 npm 编译前端",
	RunE: func(c *cobra.Command, args []string) error {
		fmt.Println("=============  前端编译开始 ============")
		// 获取path路径下的npm命令
		path, err := exec.LookPath("npm")
		if err != nil {
			log.Fatalln("请安装 npm 在你的 PATH 路径下")
		}

		// 执行npm run build
		cmd := exec.Command(path, "run", "build")
		cmd.Dir = frontendFolder
		// 将输出保存在out中
		out, err := cmd.CombinedOutput()
		if err != nil {
			fmt.Println(string(out))
			fmt.Println("=============  前端编译失败 ============")
			return err
		}
		// 打印输出
		fmt.Print(string(out))
		fmt.Println("=============  前端编译成功 ============")
		return nil
	},
}

var buildAllCommand = &cobra.Command{
	Use:   "all",
	Short: "同时编译前端和后端",
	RunE: func(c *cobra.Command, args []string) error {
		err := buildFrontendCommand.RunE(c, args)
		if err != nil {
			return err
		}
		err = buildBackendCommand.RunE(c, args)
		if err != nil {
			return err
		}
		return nil
	},
}
```

直通 go 命令（npm 一样），`framework/command/cmd_go.go`：

```go
// go just run local go bin
var goCommand = &cobra.Command{
	Use:   "go",
	Short: "运行 path/go 程序，要求go 必须安装",
	RunE: func(c *cobra.Command, args []string) error {
		fmt.Println("=============  执行 go 命令 ============")
		path, err := exec.LookPath("go")
		if err != nil {
			log.Fatalln("gob go: should install go in your PATH")
		}

		cmd := exec.Command(path, args...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Run()
		return nil
	},
}
```

挂载，`framework/command/kernel.go`：

```go
	// 挂载 build 命令  
	root.AddCommand(initBuildCommand())
	// 挂载 go 命令
	root.AddCommand(goCommand)
	// 挂载 npm 命令
	root.AddCommand(npmCommand)
```

### 代码验证

运行命令验证：`gob build self/backend/frontend/all`、`gob go mod tidy`、`gob npm run dev`...

## 19、20、提效：实现调试模式

调试模式：修改源码时自动重新编译运行。

前端用 vue 的话，已经自带调试模式了（ `npm run dev`），后端要自己实现调试模式。

### 如何实现

上一节的前后端一体化的架构方案中，是将 API 层往上提。

使用 Golang 替代网关的逻辑，先转发到编译文件夹 `dist` 中。

```mermaid
flowchart TD

subgraph new
_Gateway --> _HTML
end

subgraph old
Nginx --> HTML
Nginx --> API
end
```

但是前端启动调试模式并不生成编译后的文件，所以上节课的转发功能也用不上了。

所以这节设计一个反向代理 proxy 服务，由反代服务对请求进行分发，先转发到后端。

```mermaid
flowchart TD

subgraph 反代
proxy --> 前端服务
proxy --> 后端服务
end
subgraph 代码
前端代码 -- 监听更新 -->前端服务
后端代码 -- 监听更新 -->后端服务
end

```

Golang 中的 `net/http/httputil` 包中提供了 `ReverseProxy` 可以实现反代功能：

```go
// 反向代理
type ReverseProxy struct {
    // Director这个函数传入的参数是新复制的一个请求，我们可以修改这个请求
    // 比如修改请求的请求Host或者请求URL等
	Director func(*http.Request)

	// Transport 代表底层的连接池设置，比如连接最长保持多久等
    // 如果不填的话，则使用默认的设置
	Transport http.RoundTripper

	// FlushInterval表示多久将下游的response的数据拷贝到proxy的response
	FlushInterval time.Duration

	// ErrorLog 表示错误日志打印的句柄
	ErrorLog *log.Logger

	// BufferPool表示将下游response拷贝到proxy的response的时候使用的缓冲池大小
	BufferPool BufferPool

	// ModifyResponse 函数表示，如果要将下游的response内容进行修改，再传递给proxy
    // 的response，这个函数就可以进行设置，但是如果这个函数返回了error，则将response
    // 传递进入ErrorHandler，否则使用默认设置
	ModifyResponse func(*http.Response) error

	// ErrorHandler 处理ModifyResponse返回的Error
	ErrorHandler func(http.ResponseWriter, *http.Request, error)
}
```

- Director 的参数是请求，表示如何对请求进行转发。
- ModifyResponse 字段可以对下游的返回数据进行修改。
- ErrorHandler 字段函数可以处理 ModifyResponse 字段返回的错误。

需要做到：

- dev 命令
- proxy 实现
- 配置项
- 监听与编译重启

### 代码实现

`framework/command/dev.go`：

```go
// 初始化Dev命令
func initDevCommand() *cobra.Command {
	devCommand.AddCommand(devBackendCommand)
	devCommand.AddCommand(devFrontendCommand)
	devCommand.AddCommand(devAllCommand)
	return devCommand
}
// devCommand 为调试模式的一级命令
var devCommand = &cobra.Command{
	Use:   "dev",
	Short: "调试模式",
	RunE: func(c *cobra.Command, args []string) error {
		c.Help()
		return nil
	},
}
// devBackendCommand 启动后端调试模式
var devBackendCommand = &cobra.Command{
	Use:   "backend",
	Short: "启动后端调试模式",
	RunE: func(c *cobra.Command, args []string) error {
		proxy := NewProxy(c.GetContainer())
		go proxy.monitorBackend()
		if err := proxy.startProxy(false, true); err != nil {
			return err
		}
		return nil
	},
}
// devFrontendCommand 启动前端调试模式
var devFrontendCommand = &cobra.Command{
	Use:   "frontend",
	Short: "启动前端调试模式",
	RunE: func(c *cobra.Command, args []string) error {
		// 启动前端服务
		proxy := NewProxy(c.GetContainer())
		return proxy.startProxy(true, false)
	},
}
var devAllCommand = &cobra.Command{
	Use:   "all",
	Short: "同时启动前端和后端调试",
	RunE: func(c *cobra.Command, args []string) error {
		proxy := NewProxy(c.GetContainer())
		go proxy.monitorBackend()
		if err := proxy.startProxy(true, true); err != nil {
			return err
		}
		return nil
	},
}

// =========================================

// devConfig 代表调试模式的配置信息
type devConfig struct {
	Port    string   // 调试模式最终监听的端口，默认为 8070
	Backend struct { // 后端调试模式配置
		RefreshTime   int    // 调试模式后端更新时间, 默认1s
		Port          string // 后端监听端口， 默认 8072
		MonitorFolder string // 监听文件夹，默认为AppFolder
	}
	Frontend struct { // 前端调试模式配置
		Port string // 前端启动端口, 默认 8071
	}
}

// 初始化配置文件
func initDevConfig(c framework.Container) *devConfig {
	// 设置默认值
	config := &devConfig{
		Port: "8070",
		Backend: struct {
			RefreshTime   int
			Port          string
			MonitorFolder string
		}{
			1,
			"8072",
			"",
		},
		Frontend: struct {
			Port string
		}{
			"8071",
		},
	}
	// 容器中获取配置服务
	configService := c.MustMake(contract.ConfigKey).(contract.Config)
	// 每个配置项进行检查
	if configService.IsExist("app.dev.port") {
		config.Port = configService.GetString("app.dev.port")
	}
	if configService.IsExist("app.dev.backend.refresh_time") {
		config.Backend.RefreshTime = configService.GetInt("app.dev.backend.refresh_time")
	}
	if configService.IsExist("app.dev.backend.port") {
		config.Backend.Port = configService.GetString("app.dev.backend.port")
	}
	// monitorFolder 默认使用目录服务的 AppFolder()
	monitorFolder := configService.GetString("app.dev.backend.monitor_folder")
	if monitorFolder == "" {
		appService := c.MustMake(contract.AppKey).(contract.App)
		config.Backend.MonitorFolder = appService.AppFolder()
	}

	if configService.IsExist("app.dev.frontend.port") {
		config.Frontend.Port = configService.GetString("app.dev.frontend.port")
	}
	return config
}

// Proxy 代表serve启动的服务器代理
type Proxy struct {
	devConfig   *devConfig // 配置文件
	backendPid  int        // 当前的 backend 服务的 pid
	frontendPid int        // 当前的 frontend 服务的 pid
}

// NewProxy 初始化一个Proxy
func NewProxy(c framework.Container) *Proxy {
	config := initDevConfig(c)
	return &Proxy{
		devConfig: config,
	}
}

// 重新启动一个proxy网关
func (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {
	if p.frontendPid == 0 && p.backendPid == 0 {
		fmt.Println("前端和后端服务都不存在")
		return nil
	}

	// 后端服务存在
	if p.frontendPid == 0 && p.backendPid != 0 {
		return httputil.NewSingleHostReverseProxy(backend)
	}
	// 前端服务存在
	if p.backendPid == 0 && p.frontendPid != 0 {
		return httputil.NewSingleHostReverseProxy(frontend)
	}

	// 两个都有进程
	// 先创建一个后端服务的 directory
	director := func(req *http.Request) {
		if req.URL.Path == "/" || req.URL.Path == "/app.js" {
			req.URL.Scheme = frontend.Scheme
			req.URL.Host = frontend.Host
		} else {
			req.URL.Scheme = backend.Scheme
			req.URL.Host = backend.Host
		}
	}

	// 定义一个 NotFoundErr
	NotFoundErr := errors.New("response is 404, need to redirect")
	return &httputil.ReverseProxy{
		Director: director, // 先转发到后端服务
		ModifyResponse: func(response *http.Response) error {
			// 如果后端服务返回了404，我们返回 NotFoundErr 会进入到 errorHandler 中
			if response.StatusCode == 404 {
				return NotFoundErr
			}
			return nil
		},
		ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {
			// 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer
			if errors.Is(err, NotFoundErr) {
				httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)
			}
		}}
}

// 启动proxy服务，并且根据参数启动前端服务或者后端服务
func (p *Proxy) startProxy(startFrontend, startBackend bool) (err error) {
	var backendURL, frontendURL *url.URL
	// 启动后端
	if startBackend {
		if err = p.firstBuildBackend(); err != nil {
			fmt.Println("第一次编译失败：", err.Error())
			return
		}
		if err = p.restartBackend(); err != nil {
			return
		}
	}
	// 启动前端
	if startFrontend {
		if err = p.restartFrontend(); err != nil {
			return
		}
	}

	if frontendURL, err = url.Parse(fmt.Sprintf("%s%s", "http://127.0.0.1:", p.devConfig.Frontend.Port)); err != nil {
		return
	}
	if backendURL, err = url.Parse(fmt.Sprintf("%s%s", "http://127.0.0.1:", p.devConfig.Backend.Port)); err != nil {
		return
	}

	// 设置反向代理
	proxyReverse := p.newProxyReverseProxy(frontendURL, backendURL)
	proxyServer := &http.Server{
		Addr:    "127.0.0.1:" + p.devConfig.Port,
		Handler: proxyReverse,
	}

	fmt.Println("代理服务启动:", "http://"+proxyServer.Addr)
	// 启动proxy服务
	if err = proxyServer.ListenAndServe(); err != nil {
		fmt.Println(err)
	}
	return nil
}

// rebuildBackend 重新编译后端
func (p *Proxy) rebuildBackend() error {
	// 重新编译
	cmdBuild := exec.Command("./gob", "build", "backend")
	cmdBuild.Stdout = os.Stdout
	cmdBuild.Stderr = os.Stderr
	if err := cmdBuild.Start(); err == nil {
		err = cmdBuild.Wait()
		if err != nil {
			return err
		}
	}
	return nil
}

// firstBuildBackend 第一次编译后端
func (p *Proxy) firstBuildBackend() error {
	// 重新编译
	cmdBuild := exec.Command("go", "run", ".", "build", "backend")
	cmdBuild.Stdout = os.Stdout
	cmdBuild.Stderr = os.Stderr
	if err := cmdBuild.Start(); err == nil {
		if err = cmdBuild.Wait(); err != nil {
			return err
		}
	}
	return nil
}

// restartBackend 启动后端服务
func (p *Proxy) restartBackend() error {
	// 杀死之前的进程
	if p.backendPid != 0 {
		util.KillProcess(p.backendPid, syscall.SIGKILL)
		p.backendPid = 0
	}

	// 设置随机端口，真实后端的端口
	port := p.devConfig.Backend.Port
	gobAddress := fmt.Sprintf(":" + port)
	// 使用命令行启动后端进程
	cmd := exec.Command("./gob", "app", "start", "--address="+gobAddress)
	//cmd := exec.Command("go", "run", ".", "app", "start", "--address="+gobAddress)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Println("启动后端服务: ", "http://127.0.0.1:"+port)
	if err := cmd.Start(); err != nil {
		fmt.Println(err)
	}
	p.backendPid = cmd.Process.Pid
	fmt.Println("后端服务pid:", p.backendPid)
	return nil
}

// 启动前端服务
func (p *Proxy) restartFrontend() error {
	// 杀死之前的进程
	if p.frontendPid != 0 {
		util.KillProcess(p.frontendPid, syscall.SIGKILL)
		p.frontendPid = 0
	}

	// 开启 npm run dev
	port := p.devConfig.Frontend.Port
	path, err := exec.LookPath("npm")
	if err != nil {
		return err
	}

	// 把 port 参数传递进npm脚本里
	cmd := exec.Command(path, "run", "dev", "--", "--port", port)
	cmd.Dir = frontendFolder
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Println("启动前端服务: ", "http://127.0.0.1:"+port)
	if err = cmd.Start(); err != nil {
		fmt.Println(err)
	}
	p.frontendPid = cmd.Process.Pid
	fmt.Println("前端服务pid:", p.frontendPid)
	return nil
}

// monitorBackend 监听应用文件
func (p *Proxy) monitorBackend() (err error) {
	// 监听
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return
	}
	defer watcher.Close()

	// 开启监听目标文件夹
	appFolder := p.devConfig.Backend.MonitorFolder
	fmt.Println("监控文件夹：", appFolder)
	// 监听所有子目录，需要使用filepath.walk
	filepath.Walk(appFolder, func(path string, info os.FileInfo, err error) error {
		if info != nil && !info.IsDir() {
			return nil
		}
		// 如果是隐藏的目录比如 . 或者 .. 则不用进行监控
		if util.IsHiddenDirectory(path) {
			return nil
		}
		return watcher.Add(path)
	})

	// 开启计时时间机制
	refreshTime := p.devConfig.Backend.RefreshTime
	t := time.NewTimer(time.Duration(refreshTime) * time.Second)
	// 先停止计时器
	t.Stop()
	for {
		select {
		case <-t.C:
			// 计时器时间到了，代表之前有文件更新事件重置过计时器
			// 即有文件更新
			fmt.Println("...检测到文件更新，重启服务开始...")
			if err := p.rebuildBackend(); err != nil {
				fmt.Println("重新编译失败：", err.Error())
			} else {
				if err := p.restartBackend(); err != nil {
					fmt.Println("重新启动失败：", err.Error())
				}
			}
			fmt.Println("...检测到文件更新，重启服务结束...")
			// 停止计时器
			t.Stop()
		case _, ok := <-watcher.Events:
			if !ok {
				continue
			}
			// 有文件更新事件，重置计时器
			t.Reset(time.Duration(refreshTime) * time.Second)
		case err, ok := <-watcher.Errors:
			if !ok {
				continue
			}
			fmt.Println("监听文件夹错误：", err.Error())
			t.Reset(time.Duration(refreshTime) * time.Second)
		}
	}
}
```

添加 app 启动 address 参数，`framework/command/app.go`：

```go
// initAppCommand 初始化app命令和其子命令
func initAppCommand() *cobra.Command {
	// 设置启动地址
	appStartCommand.Flags().StringVar(&appAddress, "address", ":8080", "app启动端口，默认为8080")  
	appCommand.AddCommand(appStartCommand)
	return appCommand
}
...
// appStartCommand 启动一个Web服务
var appStartCommand = &cobra.Command{
	...
	RunE: func(c *cobra.Command, args []string) error {
		...
		// 创建一个Server服务
		server := &http.Server{
			Handler: core,
			Addr:    appAddress,     // <------
		}
```

app 服务添加获取 app 路径的方法：

`framework/contract/app.go`：

```go
	// AppFolder 定义业务代码所在的目录，用于监控文件变更使用
	AppFolder() string
```

`framework/provider/app/service.go`：

```go
// AppFolder 定义业务代码所在的目录，用于监控文件变更使用
func (s *AppService) AppFolder() string {
	if val, ok := s.configMap["app_folder"]; ok {
		return val
	}
	return filepath.Join(s.BaseFolder(), "app")
}
```

挂载命令， `framework/command/kernel.go` 增加：

```go
	// 挂载 dev 调试命令
	root.AddCommand(initDevCommand())
```

配置文件,`config/dev/app.yaml`：

```yaml
dev: # 调试模式
  port: 8070 # 调试模式最终监听的端口，默认为 8070
  frontend: # 前端调试模式配置
    port: 8071 # 前端监听端口, 默认 8071
  backend: # 后端调试模式配置
    refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s
    port: 8072 # 后端监听端口，默认 8072
    monitor_folder: "" # 监听文件夹地址，为空或者不填默认为 AppFolder

```

### 代码验证

启动命令 `./gob dev all` ，修改后端代码时能自动构建启动，并且转发到前端服务。

## 21、22、自动化

## 23、管理接口

## 24、管理进程

## 25、26、GORM

## 27、缓存服务

## 28、SSH

## 29、周边

## 30、设计先于实战

## 31、32、通用模块

## 33、34、业务开发

## 其他

## Todo

### 框架已发现待优化

- [ ] 梳理引入包
    - [ ] 源码引入
    - [ ] 三方库引入使用
- [ ] 补充 command 代码文件开头说明文档，方便查看
    - [ ] 包括命令说明、可选配置项
- [ ] 热更新覆盖全部服务
- [ ] 同时支持多个日志输出
- [ ] 优化统一日志打印格式
- [ ] 调试模式时文件监控比服务启动还提前，编译完成前修改文件可能会导致空指针

### 框架未来支持功能
